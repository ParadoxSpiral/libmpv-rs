/* automatically generated by rust-bindgen */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const MPV_ENABLE_DEPRECATED: u32 = 1;
pub const MPV_RENDER_API_TYPE_OPENGL: &'static [u8; 7usize] = b"opengl\0";
pub const MPV_RENDER_API_TYPE_SW: &'static [u8; 3usize] = b"sw\0";
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__mbstate_t {{ union }}")
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_attr_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_attr_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_cond_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_mutex_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_rwlock_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_rwlock_t {{ __sig: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl ::std::fmt::Debug for _opaque_pthread_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "_opaque_pthread_t {{ __sig: {:?}, __cleanup_stack: {:?}, __opaque: [{}] }}",
            self.__sig,
            self.__cleanup_stack,
            self.__opaque
                .iter()
                .enumerate()
                .map(|(i, v)| format!("{}{:?}", if i > 0 { ", " } else { "" }, v))
                .collect::<String>()
        )
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    #[doc = " Return the MPV_CLIENT_API_VERSION the mpv source has been compiled with."]
    pub fn mpv_client_api_version() -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_handle {
    _unused: [u8; 0],
}
#[doc = " No error happened (used to signal successful operation)."]
#[doc = " Keep in mind that many API functions returning error codes can also"]
#[doc = " return positive values, which also indicate success. API users can"]
#[doc = " hardcode the fact that \">= 0\" means success."]
pub const mpv_error_MPV_ERROR_SUCCESS: mpv_error = 0;
#[doc = " The event ringbuffer is full. This means the client is choked, and can't"]
#[doc = " receive any events. This can happen when too many asynchronous requests"]
#[doc = " have been made, but not answered. Probably never happens in practice,"]
#[doc = " unless the mpv core is frozen for some reason, and the client keeps"]
#[doc = " making asynchronous requests. (Bugs in the client API implementation"]
#[doc = " could also trigger this, e.g. if events become \"lost\".)"]
pub const mpv_error_MPV_ERROR_EVENT_QUEUE_FULL: mpv_error = -1;
#[doc = " Memory allocation failed."]
pub const mpv_error_MPV_ERROR_NOMEM: mpv_error = -2;
#[doc = " The mpv core wasn't configured and initialized yet. See the notes in"]
#[doc = " mpv_create()."]
pub const mpv_error_MPV_ERROR_UNINITIALIZED: mpv_error = -3;
#[doc = " Generic catch-all error if a parameter is set to an invalid or"]
#[doc = " unsupported value. This is used if there is no better error code."]
pub const mpv_error_MPV_ERROR_INVALID_PARAMETER: mpv_error = -4;
#[doc = " Trying to set an option that doesn't exist."]
pub const mpv_error_MPV_ERROR_OPTION_NOT_FOUND: mpv_error = -5;
#[doc = " Trying to set an option using an unsupported MPV_FORMAT."]
pub const mpv_error_MPV_ERROR_OPTION_FORMAT: mpv_error = -6;
#[doc = " Setting the option failed. Typically this happens if the provided option"]
#[doc = " value could not be parsed."]
pub const mpv_error_MPV_ERROR_OPTION_ERROR: mpv_error = -7;
#[doc = " The accessed property doesn't exist."]
pub const mpv_error_MPV_ERROR_PROPERTY_NOT_FOUND: mpv_error = -8;
#[doc = " Trying to set or get a property using an unsupported MPV_FORMAT."]
pub const mpv_error_MPV_ERROR_PROPERTY_FORMAT: mpv_error = -9;
#[doc = " The property exists, but is not available. This usually happens when the"]
#[doc = " associated subsystem is not active, e.g. querying audio parameters while"]
#[doc = " audio is disabled."]
pub const mpv_error_MPV_ERROR_PROPERTY_UNAVAILABLE: mpv_error = -10;
#[doc = " Error setting or getting a property."]
pub const mpv_error_MPV_ERROR_PROPERTY_ERROR: mpv_error = -11;
#[doc = " General error when running a command with mpv_command and similar."]
pub const mpv_error_MPV_ERROR_COMMAND: mpv_error = -12;
#[doc = " Generic error on loading (usually used with mpv_event_end_file.error)."]
pub const mpv_error_MPV_ERROR_LOADING_FAILED: mpv_error = -13;
#[doc = " Initializing the audio output failed."]
pub const mpv_error_MPV_ERROR_AO_INIT_FAILED: mpv_error = -14;
#[doc = " Initializing the video output failed."]
pub const mpv_error_MPV_ERROR_VO_INIT_FAILED: mpv_error = -15;
#[doc = " There was no audio or video data to play. This also happens if the"]
#[doc = " file was recognized, but did not contain any audio or video streams,"]
#[doc = " or no streams were selected."]
pub const mpv_error_MPV_ERROR_NOTHING_TO_PLAY: mpv_error = -16;
#[doc = " When trying to load the file, the file format could not be determined,"]
#[doc = " or the file was too broken to open it."]
pub const mpv_error_MPV_ERROR_UNKNOWN_FORMAT: mpv_error = -17;
#[doc = " Generic error for signaling that certain system requirements are not"]
#[doc = " fulfilled."]
pub const mpv_error_MPV_ERROR_UNSUPPORTED: mpv_error = -18;
#[doc = " The API function which was called is a stub only."]
pub const mpv_error_MPV_ERROR_NOT_IMPLEMENTED: mpv_error = -19;
#[doc = " Unspecified error."]
pub const mpv_error_MPV_ERROR_GENERIC: mpv_error = -20;
#[doc = " List of error codes than can be returned by API functions. 0 and positive"]
#[doc = " return values always mean success, negative values are always errors."]
pub type mpv_error = i32;
extern "C" {
    #[doc = " Return a string describing the error. For unknown errors, the string"]
    #[doc = " \"unknown error\" is returned."]
    #[doc = ""]
    #[doc = " @param error error number, see enum mpv_error"]
    #[doc = " @return A static string describing the error. The string is completely"]
    #[doc = "         static, i.e. doesn't need to be deallocated, and is valid forever."]
    pub fn mpv_error_string(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " General function to deallocate memory returned by some of the API functions."]
    #[doc = " Call this only if it's explicitly documented as allowed. Calling this on"]
    #[doc = " mpv memory not owned by the caller will lead to undefined behavior."]
    #[doc = ""]
    #[doc = " @param data A valid pointer returned by the API, or NULL."]
    pub fn mpv_free(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Return the name of this client handle. Every client has its own unique"]
    #[doc = " name, which is mostly used for user interface purposes."]
    #[doc = ""]
    #[doc = " @return The client name. The string is read-only and is valid until the"]
    #[doc = "         mpv_handle is destroyed."]
    pub fn mpv_client_name(ctx: *mut mpv_handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the ID of this client handle. Every client has its own unique ID. This"]
    #[doc = " ID is never reused by the core, even if the mpv_handle at hand gets destroyed"]
    #[doc = " and new handles get allocated."]
    #[doc = ""]
    #[doc = " IDs are never 0 or negative."]
    #[doc = ""]
    #[doc = " Some mpv APIs (not necessarily all) accept a name in the form \"@<id>\" in"]
    #[doc = " addition of the proper mpv_client_name(), where \"<id>\" is the ID in decimal"]
    #[doc = " form (e.g. \"@123\"). For example, the \"script-message-to\" command takes the"]
    #[doc = " client name as first argument, but also accepts the client ID formatted in"]
    #[doc = " this manner."]
    #[doc = ""]
    #[doc = " @return The client ID."]
    pub fn mpv_client_id(ctx: *mut mpv_handle) -> i64;
}
extern "C" {
    #[doc = " Create a new mpv instance and an associated client API handle to control"]
    #[doc = " the mpv instance. This instance is in a pre-initialized state,"]
    #[doc = " and needs to be initialized to be actually used with most other API"]
    #[doc = " functions."]
    #[doc = ""]
    #[doc = " Some API functions will return MPV_ERROR_UNINITIALIZED in the uninitialized"]
    #[doc = " state. You can call mpv_set_property() (or mpv_set_property_string() and"]
    #[doc = " other variants, and before mpv 0.21.0 mpv_set_option() etc.) to set initial"]
    #[doc = " options. After this, call mpv_initialize() to start the player, and then use"]
    #[doc = " e.g. mpv_command() to start playback of a file."]
    #[doc = ""]
    #[doc = " The point of separating handle creation and actual initialization is that"]
    #[doc = " you can configure things which can't be changed during runtime."]
    #[doc = ""]
    #[doc = " Unlike the command line player, this will have initial settings suitable"]
    #[doc = " for embedding in applications. The following settings are different:"]
    #[doc = " - stdin/stdout/stderr and the terminal will never be accessed. This is"]
    #[doc = "   equivalent to setting the --no-terminal option."]
    #[doc = "   (Technically, this also suppresses C signal handling.)"]
    #[doc = " - No config files will be loaded. This is roughly equivalent to using"]
    #[doc = "   --config=no. Since libmpv 1.15, you can actually re-enable this option,"]
    #[doc = "   which will make libmpv load config files during mpv_initialize(). If you"]
    #[doc = "   do this, you are strongly encouraged to set the \"config-dir\" option too."]
    #[doc = "   (Otherwise it will load the mpv command line player's config.)"]
    #[doc = "   For example:"]
    #[doc = "      mpv_set_option_string(mpv, \"config-dir\", \"/my/path\"); // set config root"]
    #[doc = "      mpv_set_option_string(mpv, \"config\", \"yes\"); // enable config loading"]
    #[doc = "      (call mpv_initialize() _after_ this)"]
    #[doc = " - Idle mode is enabled, which means the playback core will enter idle mode"]
    #[doc = "   if there are no more files to play on the internal playlist, instead of"]
    #[doc = "   exiting. This is equivalent to the --idle option."]
    #[doc = " - Disable parts of input handling."]
    #[doc = " - Most of the different settings can be viewed with the command line player"]
    #[doc = "   by running \"mpv --show-profile=libmpv\"."]
    #[doc = ""]
    #[doc = " All this assumes that API users want a mpv instance that is strictly"]
    #[doc = " isolated from the command line player's configuration, user settings, and"]
    #[doc = " so on. You can re-enable disabled features by setting the appropriate"]
    #[doc = " options."]
    #[doc = ""]
    #[doc = " The mpv command line parser is not available through this API, but you can"]
    #[doc = " set individual options with mpv_set_property(). Files for playback must be"]
    #[doc = " loaded with mpv_command() or others."]
    #[doc = ""]
    #[doc = " Note that you should avoid doing concurrent accesses on the uninitialized"]
    #[doc = " client handle. (Whether concurrent access is definitely allowed or not has"]
    #[doc = " yet to be decided.)"]
    #[doc = ""]
    #[doc = " @return a new mpv client API handle. Returns NULL on error. Currently, this"]
    #[doc = "         can happen in the following situations:"]
    #[doc = "         - out of memory"]
    #[doc = "         - LC_NUMERIC is not set to \"C\" (see general remarks)"]
    pub fn mpv_create() -> *mut mpv_handle;
}
extern "C" {
    #[doc = " Initialize an uninitialized mpv instance. If the mpv instance is already"]
    #[doc = " running, an error is returned."]
    #[doc = ""]
    #[doc = " This function needs to be called to make full use of the client API if the"]
    #[doc = " client API handle was created with mpv_create()."]
    #[doc = ""]
    #[doc = " Only the following options are required to be set _before_ mpv_initialize():"]
    #[doc = "      - options which are only read at initialization time:"]
    #[doc = "        - config"]
    #[doc = "        - config-dir"]
    #[doc = "        - input-conf"]
    #[doc = "        - load-scripts"]
    #[doc = "        - script"]
    #[doc = "        - player-operation-mode"]
    #[doc = "        - input-app-events (OSX)"]
    #[doc = "      - all encoding mode options"]
    #[doc = ""]
    #[doc = " @return error code"]
    pub fn mpv_initialize(ctx: *mut mpv_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disconnect and destroy the mpv_handle. ctx will be deallocated with this"]
    #[doc = " API call."]
    #[doc = ""]
    #[doc = " If the last mpv_handle is detached, the core player is destroyed. In"]
    #[doc = " addition, if there are only weak mpv_handles (such as created by"]
    #[doc = " mpv_create_weak_client() or internal scripts), these mpv_handles will"]
    #[doc = " be sent MPV_EVENT_SHUTDOWN. This function may block until these clients"]
    #[doc = " have responded to the shutdown event, and the core is finally destroyed."]
    pub fn mpv_destroy(ctx: *mut mpv_handle);
}
extern "C" {
    #[doc = " Similar to mpv_destroy(), but brings the player and all clients down"]
    #[doc = " as well, and waits until all of them are destroyed. This function blocks. The"]
    #[doc = " advantage over mpv_destroy() is that while mpv_destroy() merely"]
    #[doc = " detaches the client handle from the player, this function quits the player,"]
    #[doc = " waits until all other clients are destroyed (i.e. all mpv_handles are"]
    #[doc = " detached), and also waits for the final termination of the player."]
    #[doc = ""]
    #[doc = " Since mpv_destroy() is called somewhere on the way, it's not safe to"]
    #[doc = " call other functions concurrently on the same context."]
    #[doc = ""]
    #[doc = " Since mpv client API version 1.29:"]
    #[doc = "  The first call on any mpv_handle will block until the core is destroyed."]
    #[doc = "  This means it will wait until other mpv_handle have been destroyed. If you"]
    #[doc = "  want asynchronous destruction, just run the \"quit\" command, and then react"]
    #[doc = "  to the MPV_EVENT_SHUTDOWN event."]
    #[doc = "  If another mpv_handle already called mpv_terminate_destroy(), this call will"]
    #[doc = "  not actually block. It will destroy the mpv_handle, and exit immediately,"]
    #[doc = "  while other mpv_handles might still be uninitializing."]
    #[doc = ""]
    #[doc = " Before mpv client API version 1.29:"]
    #[doc = "  If this is called on a mpv_handle that was not created with mpv_create(),"]
    #[doc = "  this function will merely send a quit command and then call"]
    #[doc = "  mpv_destroy(), without waiting for the actual shutdown."]
    pub fn mpv_terminate_destroy(ctx: *mut mpv_handle);
}
extern "C" {
    #[doc = " Create a new client handle connected to the same player core as ctx. This"]
    #[doc = " context has its own event queue, its own mpv_request_event() state, its own"]
    #[doc = " mpv_request_log_messages() state, its own set of observed properties, and"]
    #[doc = " its own state for asynchronous operations. Otherwise, everything is shared."]
    #[doc = ""]
    #[doc = " This handle should be destroyed with mpv_destroy() if no longer"]
    #[doc = " needed. The core will live as long as there is at least 1 handle referencing"]
    #[doc = " it. Any handle can make the core quit, which will result in every handle"]
    #[doc = " receiving MPV_EVENT_SHUTDOWN."]
    #[doc = ""]
    #[doc = " This function can not be called before the main handle was initialized with"]
    #[doc = " mpv_initialize(). The new handle is always initialized, unless ctx=NULL was"]
    #[doc = " passed."]
    #[doc = ""]
    #[doc = " @param ctx Used to get the reference to the mpv core; handle-specific"]
    #[doc = "            settings and parameters are not used."]
    #[doc = "            If NULL, this function behaves like mpv_create() (ignores name)."]
    #[doc = " @param name The client name. This will be returned by mpv_client_name(). If"]
    #[doc = "             the name is already in use, or contains non-alphanumeric"]
    #[doc = "             characters (other than '_'), the name is modified to fit."]
    #[doc = "             If NULL, an arbitrary name is automatically chosen."]
    #[doc = " @return a new handle, or NULL on error"]
    pub fn mpv_create_client(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut mpv_handle;
}
extern "C" {
    #[doc = " This is the same as mpv_create_client(), but the created mpv_handle is"]
    #[doc = " treated as a weak reference. If all mpv_handles referencing a core are"]
    #[doc = " weak references, the core is automatically destroyed. (This still goes"]
    #[doc = " through normal uninit of course. Effectively, if the last non-weak mpv_handle"]
    #[doc = " is destroyed, then the weak mpv_handles receive MPV_EVENT_SHUTDOWN and are"]
    #[doc = " asked to terminate as well.)"]
    #[doc = ""]
    #[doc = " Note if you want to use this like refcounting: you have to be aware that"]
    #[doc = " mpv_terminate_destroy() _and_ mpv_destroy() for the last non-weak"]
    #[doc = " mpv_handle will block until all weak mpv_handles are destroyed."]
    pub fn mpv_create_weak_client(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut mpv_handle;
}
extern "C" {
    #[doc = " Load a config file. This loads and parses the file, and sets every entry in"]
    #[doc = " the config file's default section as if mpv_set_option_string() is called."]
    #[doc = ""]
    #[doc = " The filename should be an absolute path. If it isn't, the actual path used"]
    #[doc = " is unspecified. (Note: an absolute path starts with '/' on UNIX.) If the"]
    #[doc = " file wasn't found, MPV_ERROR_INVALID_PARAMETER is returned."]
    #[doc = ""]
    #[doc = " If a fatal error happens when parsing a config file, MPV_ERROR_OPTION_ERROR"]
    #[doc = " is returned. Errors when setting options as well as other types or errors"]
    #[doc = " are ignored (even if options do not exist). You can still try to capture"]
    #[doc = " the resulting error messages with mpv_request_log_messages(). Note that it's"]
    #[doc = " possible that some options were successfully set even if any of these errors"]
    #[doc = " happen."]
    #[doc = ""]
    #[doc = " @param filename absolute path to the config file on the local filesystem"]
    #[doc = " @return error code"]
    pub fn mpv_load_config_file(
        ctx: *mut mpv_handle,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the internal time in microseconds. This has an arbitrary start offset,"]
    #[doc = " but will never wrap or go backwards."]
    #[doc = ""]
    #[doc = " Note that this is always the real time, and doesn't necessarily have to do"]
    #[doc = " with playback time. For example, playback could go faster or slower due to"]
    #[doc = " playback speed, or due to playback being paused. Use the \"time-pos\" property"]
    #[doc = " instead to get the playback status."]
    #[doc = ""]
    #[doc = " Unlike other libmpv APIs, this can be called at absolutely any time (even"]
    #[doc = " within wakeup callbacks), as long as the context is valid."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    pub fn mpv_get_time_us(ctx: *mut mpv_handle) -> i64;
}
#[doc = " Invalid. Sometimes used for empty values. This is always defined to 0,"]
#[doc = " so a normal 0-init of mpv_format (or e.g. mpv_node) is guaranteed to set"]
#[doc = " this it to MPV_FORMAT_NONE (which makes some things saner as consequence)."]
pub const mpv_format_MPV_FORMAT_NONE: mpv_format = 0;
#[doc = " The basic type is char*. It returns the raw property string, like"]
#[doc = " using ${=property} in input.conf (see input.rst)."]
#[doc = ""]
#[doc = " NULL isn't an allowed value."]
#[doc = ""]
#[doc = " Warning: although the encoding is usually UTF-8, this is not always the"]
#[doc = "          case. File tags often store strings in some legacy codepage,"]
#[doc = "          and even filenames don't necessarily have to be in UTF-8 (at"]
#[doc = "          least on Linux). If you pass the strings to code that requires"]
#[doc = "          valid UTF-8, you have to sanitize it in some way."]
#[doc = "          On Windows, filenames are always UTF-8, and libmpv converts"]
#[doc = "          between UTF-8 and UTF-16 when using win32 API functions. See"]
#[doc = "          the \"Encoding of filenames\" section for details."]
#[doc = ""]
#[doc = " Example for reading:"]
#[doc = ""]
#[doc = "     char *result = NULL;"]
#[doc = "     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_STRING, &result) < 0)"]
#[doc = "         goto error;"]
#[doc = "     printf(\"%s\\n\", result);"]
#[doc = "     mpv_free(result);"]
#[doc = ""]
#[doc = " Or just use mpv_get_property_string()."]
#[doc = ""]
#[doc = " Example for writing:"]
#[doc = ""]
#[doc = "     char *value = \"the new value\";"]
#[doc = "     // yep, you pass the address to the variable"]
#[doc = "     // (needed for symmetry with other types and mpv_get_property)"]
#[doc = "     mpv_set_property(ctx, \"property\", MPV_FORMAT_STRING, &value);"]
#[doc = ""]
#[doc = " Or just use mpv_set_property_string()."]
#[doc = ""]
pub const mpv_format_MPV_FORMAT_STRING: mpv_format = 1;
#[doc = " The basic type is char*. It returns the OSD property string, like"]
#[doc = " using ${property} in input.conf (see input.rst). In many cases, this"]
#[doc = " is the same as the raw string, but in other cases it's formatted for"]
#[doc = " display on OSD. It's intended to be human readable. Do not attempt to"]
#[doc = " parse these strings."]
#[doc = ""]
#[doc = " Only valid when doing read access. The rest works like MPV_FORMAT_STRING."]
pub const mpv_format_MPV_FORMAT_OSD_STRING: mpv_format = 2;
#[doc = " The basic type is int. The only allowed values are 0 (\"no\")"]
#[doc = " and 1 (\"yes\")."]
#[doc = ""]
#[doc = " Example for reading:"]
#[doc = ""]
#[doc = "     int result;"]
#[doc = "     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_FLAG, &result) < 0)"]
#[doc = "         goto error;"]
#[doc = "     printf(\"%s\\n\", result ? \"true\" : \"false\");"]
#[doc = ""]
#[doc = " Example for writing:"]
#[doc = ""]
#[doc = "     int flag = 1;"]
#[doc = "     mpv_set_property(ctx, \"property\", MPV_FORMAT_FLAG, &flag);"]
pub const mpv_format_MPV_FORMAT_FLAG: mpv_format = 3;
#[doc = " The basic type is int64_t."]
pub const mpv_format_MPV_FORMAT_INT64: mpv_format = 4;
#[doc = " The basic type is double."]
pub const mpv_format_MPV_FORMAT_DOUBLE: mpv_format = 5;
#[doc = " The type is mpv_node."]
#[doc = ""]
#[doc = " For reading, you usually would pass a pointer to a stack-allocated"]
#[doc = " mpv_node value to mpv, and when you're done you call"]
#[doc = " mpv_free_node_contents(&node)."]
#[doc = " You're expected not to write to the data - if you have to, copy it"]
#[doc = " first (which you have to do manually)."]
#[doc = ""]
#[doc = " For writing, you construct your own mpv_node, and pass a pointer to the"]
#[doc = " API. The API will never write to your data (and copy it if needed), so"]
#[doc = " you're free to use any form of allocation or memory management you like."]
#[doc = ""]
#[doc = " Warning: when reading, always check the mpv_node.format member. For"]
#[doc = "          example, properties might change their type in future versions"]
#[doc = "          of mpv, or sometimes even during runtime."]
#[doc = ""]
#[doc = " Example for reading:"]
#[doc = ""]
#[doc = "     mpv_node result;"]
#[doc = "     if (mpv_get_property(ctx, \"property\", MPV_FORMAT_NODE, &result) < 0)"]
#[doc = "         goto error;"]
#[doc = "     printf(\"format=%d\\n\", (int)result.format);"]
#[doc = "     mpv_free_node_contents(&result)."]
#[doc = ""]
#[doc = " Example for writing:"]
#[doc = ""]
#[doc = "     mpv_node value;"]
#[doc = "     value.format = MPV_FORMAT_STRING;"]
#[doc = "     value.u.string = \"hello\";"]
#[doc = "     mpv_set_property(ctx, \"property\", MPV_FORMAT_NODE, &value);"]
pub const mpv_format_MPV_FORMAT_NODE: mpv_format = 6;
#[doc = " Used with mpv_node only. Can usually not be used directly."]
pub const mpv_format_MPV_FORMAT_NODE_ARRAY: mpv_format = 7;
#[doc = " See MPV_FORMAT_NODE_ARRAY."]
pub const mpv_format_MPV_FORMAT_NODE_MAP: mpv_format = 8;
#[doc = " A raw, untyped byte array. Only used only with mpv_node, and only in"]
#[doc = " some very specific situations. (Some commands use it.)"]
pub const mpv_format_MPV_FORMAT_BYTE_ARRAY: mpv_format = 9;
#[doc = " Data format for options and properties. The API functions to get/set"]
#[doc = " properties and options support multiple formats, and this enum describes"]
#[doc = " them."]
pub type mpv_format = u32;
#[doc = " Generic data storage."]
#[doc = ""]
#[doc = " If mpv writes this struct (e.g. via mpv_get_property()), you must not change"]
#[doc = " the data. In some cases (mpv_get_property()), you have to free it with"]
#[doc = " mpv_free_node_contents(). If you fill this struct yourself, you're also"]
#[doc = " responsible for freeing it, and you must not call mpv_free_node_contents()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpv_node {
    pub u: mpv_node__bindgen_ty_1,
    #[doc = " Type of the data stored in this struct. This value rules what members in"]
    #[doc = " the given union can be accessed. The following formats are currently"]
    #[doc = " defined to be allowed in mpv_node:"]
    #[doc = ""]
    #[doc = "  MPV_FORMAT_STRING       (u.string)"]
    #[doc = "  MPV_FORMAT_FLAG         (u.flag)"]
    #[doc = "  MPV_FORMAT_INT64        (u.int64)"]
    #[doc = "  MPV_FORMAT_DOUBLE       (u.double_)"]
    #[doc = "  MPV_FORMAT_NODE_ARRAY   (u.list)"]
    #[doc = "  MPV_FORMAT_NODE_MAP     (u.list)"]
    #[doc = "  MPV_FORMAT_BYTE_ARRAY   (u.ba)"]
    #[doc = "  MPV_FORMAT_NONE         (no member)"]
    #[doc = ""]
    #[doc = " If you encounter a value you don't know, you must not make any"]
    #[doc = " assumptions about the contents of union u."]
    pub format: mpv_format,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpv_node__bindgen_ty_1 {
    pub string: *mut ::std::os::raw::c_char,
    #[doc = " valid if format==MPV_FORMAT_STRING"]
    pub flag: ::std::os::raw::c_int,
    #[doc = " valid if format==MPV_FORMAT_FLAG"]
    pub int64: i64,
    #[doc = " valid if format==MPV_FORMAT_INT64"]
    pub double_: f64,
    #[doc = " valid if format==MPV_FORMAT_DOUBLE */"]
    #[doc = " valid if format==MPV_FORMAT_NODE_ARRAY"]
    #[doc = "    or if format==MPV_FORMAT_NODE_MAP"]
    pub list: *mut mpv_node_list,
    #[doc = " valid if format==MPV_FORMAT_BYTE_ARRAY"]
    pub ba: *mut mpv_byte_array,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_mpv_node__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mpv_node__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(mpv_node__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node__bindgen_ty_1>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node__bindgen_ty_1>())).flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node__bindgen_ty_1),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node__bindgen_ty_1>())).int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node__bindgen_ty_1),
            "::",
            stringify!(int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node__bindgen_ty_1>())).double_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node__bindgen_ty_1),
            "::",
            stringify!(double_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node__bindgen_ty_1>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node__bindgen_ty_1>())).ba as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node__bindgen_ty_1),
            "::",
            stringify!(ba)
        )
    );
}
impl ::std::fmt::Debug for mpv_node__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "mpv_node__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mpv_node() {
    assert_eq!(
        ::std::mem::size_of::<mpv_node>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_node))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_node>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node),
            "::",
            stringify!(format)
        )
    );
}
impl ::std::fmt::Debug for mpv_node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "mpv_node {{ u: {:?}, format: {:?} }}",
            self.u, self.format
        )
    }
}
#[doc = " (see mpv_node)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_node_list {
    #[doc = " Number of entries. Negative values are not allowed."]
    pub num: ::std::os::raw::c_int,
    #[doc = " MPV_FORMAT_NODE_ARRAY:"]
    #[doc = "  values[N] refers to value of the Nth item"]
    #[doc = ""]
    #[doc = " MPV_FORMAT_NODE_MAP:"]
    #[doc = "  values[N] refers to value of the Nth key/value pair"]
    #[doc = ""]
    #[doc = " If num > 0, values[0] to values[num-1] (inclusive) are valid."]
    #[doc = " Otherwise, this can be NULL."]
    pub values: *mut mpv_node,
    #[doc = " MPV_FORMAT_NODE_ARRAY:"]
    #[doc = "  unused (typically NULL), access is not allowed"]
    #[doc = ""]
    #[doc = " MPV_FORMAT_NODE_MAP:"]
    #[doc = "  keys[N] refers to key of the Nth key/value pair. If num > 0, keys[0] to"]
    #[doc = "  keys[num-1] (inclusive) are valid. Otherwise, this can be NULL."]
    #[doc = "  The keys are in random order. The only guarantee is that keys[N] belongs"]
    #[doc = "  to the value values[N]. NULL keys are not allowed."]
    pub keys: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mpv_node_list() {
    assert_eq!(
        ::std::mem::size_of::<mpv_node_list>(),
        24usize,
        concat!("Size of: ", stringify!(mpv_node_list))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_node_list>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_node_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node_list>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node_list),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node_list>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node_list),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_node_list>())).keys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_node_list),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " (see mpv_node)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_byte_array {
    #[doc = " Pointer to the data. In what format the data is stored is up to whatever"]
    #[doc = " uses MPV_FORMAT_BYTE_ARRAY."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Size of the data pointed to by ptr."]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_mpv_byte_array() {
    assert_eq!(
        ::std::mem::size_of::<mpv_byte_array>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_byte_array))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_byte_array>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_byte_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_byte_array>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_byte_array),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_byte_array>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_byte_array),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Frees any data referenced by the node. It doesn't free the node itself."]
    #[doc = " Call this only if the mpv client API set the node. If you constructed the"]
    #[doc = " node yourself (manually), you have to free it yourself."]
    #[doc = ""]
    #[doc = " If node->format is MPV_FORMAT_NONE, this call does nothing. Likewise, if"]
    #[doc = " the client API sets a node with this format, this function doesn't need to"]
    #[doc = " be called. (This is just a clarification that there's no danger of anything"]
    #[doc = " strange happening in these cases.)"]
    pub fn mpv_free_node_contents(node: *mut mpv_node);
}
extern "C" {
    #[doc = " Set an option. Note that you can't normally set options during runtime. It"]
    #[doc = " works in uninitialized state (see mpv_create()), and in some cases in at"]
    #[doc = " runtime."]
    #[doc = ""]
    #[doc = " Using a format other than MPV_FORMAT_NODE is equivalent to constructing a"]
    #[doc = " mpv_node with the given format and data, and passing the mpv_node to this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note: this is semi-deprecated. For most purposes, this is not needed anymore."]
    #[doc = "       Starting with mpv version 0.21.0 (version 1.23) most options can be set"]
    #[doc = "       with mpv_set_property() (and related functions), and even before"]
    #[doc = "       mpv_initialize(). In some obscure corner cases, using this function"]
    #[doc = "       to set options might still be required (see"]
    #[doc = "       \"Inconsistencies between options and properties\" in the manpage). Once"]
    #[doc = "       these are resolved, the option setting functions might be fully"]
    #[doc = "       deprecated."]
    #[doc = ""]
    #[doc = " @param name Option name. This is the same as on the mpv command line, but"]
    #[doc = "             without the leading \"--\"."]
    #[doc = " @param format see enum mpv_format."]
    #[doc = " @param[in] data Option value (according to the format)."]
    #[doc = " @return error code"]
    pub fn mpv_set_option(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function to set an option to a string value. This is like"]
    #[doc = " calling mpv_set_option() with MPV_FORMAT_STRING."]
    #[doc = ""]
    #[doc = " @return error code"]
    pub fn mpv_set_option_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a command to the player. Commands are the same as those used in"]
    #[doc = " input.conf, except that this function takes parameters in a pre-split"]
    #[doc = " form."]
    #[doc = ""]
    #[doc = " The commands and their parameters are documented in input.rst."]
    #[doc = ""]
    #[doc = " Does not use OSD and string expansion by default (unlike mpv_command_string()"]
    #[doc = " and input.conf)."]
    #[doc = ""]
    #[doc = " @param[in] args NULL-terminated list of strings. Usually, the first item"]
    #[doc = "                 is the command, and the following items are arguments."]
    #[doc = " @return error code"]
    pub fn mpv_command(
        ctx: *mut mpv_handle,
        args: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as mpv_command(), but allows passing structured data in any format."]
    #[doc = " In particular, calling mpv_command() is exactly like calling"]
    #[doc = " mpv_command_node() with the format set to MPV_FORMAT_NODE_ARRAY, and"]
    #[doc = " every arg passed in order as MPV_FORMAT_STRING."]
    #[doc = ""]
    #[doc = " Does not use OSD and string expansion by default."]
    #[doc = ""]
    #[doc = " The args argument can have one of the following formats:"]
    #[doc = ""]
    #[doc = " MPV_FORMAT_NODE_ARRAY:"]
    #[doc = "      Positional arguments. Each entry is an argument using an arbitrary"]
    #[doc = "      format (the format must be compatible to the used command). Usually,"]
    #[doc = "      the first item is the command name (as MPV_FORMAT_STRING). The order"]
    #[doc = "      of arguments is as documented in each command description."]
    #[doc = ""]
    #[doc = " MPV_FORMAT_NODE_MAP:"]
    #[doc = "      Named arguments. This requires at least an entry with the key \"name\""]
    #[doc = "      to be present, which must be a string, and contains the command name."]
    #[doc = "      The special entry \"_flags\" is optional, and if present, must be an"]
    #[doc = "      array of strings, each being a command prefix to apply. All other"]
    #[doc = "      entries are interpreted as arguments. They must use the argument names"]
    #[doc = "      as documented in each command description. Some commands do not"]
    #[doc = "      support named arguments at all, and must use MPV_FORMAT_NODE_ARRAY."]
    #[doc = ""]
    #[doc = " @param[in] args mpv_node with format set to one of the values documented"]
    #[doc = "                 above (see there for details)"]
    #[doc = " @param[out] result Optional, pass NULL if unused. If not NULL, and if the"]
    #[doc = "                    function succeeds, this is set to command-specific return"]
    #[doc = "                    data. You must call mpv_free_node_contents() to free it"]
    #[doc = "                    (again, only if the command actually succeeds)."]
    #[doc = "                    Not many commands actually use this at all."]
    #[doc = " @return error code (the result parameter is not set on error)"]
    pub fn mpv_command_node(
        ctx: *mut mpv_handle,
        args: *mut mpv_node,
        result: *mut mpv_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This is essentially identical to mpv_command() but it also returns a result."]
    #[doc = ""]
    #[doc = " Does not use OSD and string expansion by default."]
    #[doc = ""]
    #[doc = " @param[in] args NULL-terminated list of strings. Usually, the first item"]
    #[doc = "                 is the command, and the following items are arguments."]
    #[doc = " @param[out] result Optional, pass NULL if unused. If not NULL, and if the"]
    #[doc = "                    function succeeds, this is set to command-specific return"]
    #[doc = "                    data. You must call mpv_free_node_contents() to free it"]
    #[doc = "                    (again, only if the command actually succeeds)."]
    #[doc = "                    Not many commands actually use this at all."]
    #[doc = " @return error code (the result parameter is not set on error)"]
    pub fn mpv_command_ret(
        ctx: *mut mpv_handle,
        args: *mut *const ::std::os::raw::c_char,
        result: *mut mpv_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as mpv_command, but use input.conf parsing for splitting arguments."]
    #[doc = " This is slightly simpler, but also more error prone, since arguments may"]
    #[doc = " need quoting/escaping."]
    #[doc = ""]
    #[doc = " This also has OSD and string expansion enabled by default."]
    pub fn mpv_command_string(
        ctx: *mut mpv_handle,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as mpv_command, but run the command asynchronously."]
    #[doc = ""]
    #[doc = " Commands are executed asynchronously. You will receive a"]
    #[doc = " MPV_EVENT_COMMAND_REPLY event. This event will also have an"]
    #[doc = " error code set if running the command failed. For commands that"]
    #[doc = " return data, the data is put into mpv_event_command.result."]
    #[doc = ""]
    #[doc = " The only case when you do not receive an event is when the function call"]
    #[doc = " itself fails. This happens only if parsing the command itself (or otherwise"]
    #[doc = " validating it) fails, i.e. the return code of the API call is not 0 or"]
    #[doc = " positive."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param reply_userdata the value mpv_event.reply_userdata of the reply will"]
    #[doc = "                       be set to (see section about asynchronous calls)"]
    #[doc = " @param args NULL-terminated list of strings (see mpv_command())"]
    #[doc = " @return error code (if parsing or queuing the command fails)"]
    pub fn mpv_command_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        args: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Same as mpv_command_node(), but run it asynchronously. Basically, this"]
    #[doc = " function is to mpv_command_node() what mpv_command_async() is to"]
    #[doc = " mpv_command()."]
    #[doc = ""]
    #[doc = " See mpv_command_async() for details."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param reply_userdata the value mpv_event.reply_userdata of the reply will"]
    #[doc = "                       be set to (see section about asynchronous calls)"]
    #[doc = " @param args as in mpv_command_node()"]
    #[doc = " @return error code (if parsing or queuing the command fails)"]
    pub fn mpv_command_node_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        args: *mut mpv_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Signal to all async requests with the matching ID to abort. This affects"]
    #[doc = " the following API calls:"]
    #[doc = ""]
    #[doc = "      mpv_command_async"]
    #[doc = "      mpv_command_node_async"]
    #[doc = ""]
    #[doc = " All of these functions take a reply_userdata parameter. This API function"]
    #[doc = " tells all requests with the matching reply_userdata value to try to return"]
    #[doc = " as soon as possible. If there are multiple requests with matching ID, it"]
    #[doc = " aborts all of them."]
    #[doc = ""]
    #[doc = " This API function is mostly asynchronous itself. It will not wait until the"]
    #[doc = " command is aborted. Instead, the command will terminate as usual, but with"]
    #[doc = " some work not done. How this is signaled depends on the specific command (for"]
    #[doc = " example, the \"subprocess\" command will indicate it by \"killed_by_us\" set to"]
    #[doc = " true in the result). How long it takes also depends on the situation. The"]
    #[doc = " aborting process is completely asynchronous."]
    #[doc = ""]
    #[doc = " Not all commands may support this functionality. In this case, this function"]
    #[doc = " will have no effect. The same is true if the request using the passed"]
    #[doc = " reply_userdata has already terminated, has not been started yet, or was"]
    #[doc = " never in use at all."]
    #[doc = ""]
    #[doc = " You have to be careful of race conditions: the time during which the abort"]
    #[doc = " request will be effective is _after_ e.g. mpv_command_async() has returned,"]
    #[doc = " and before the command has signaled completion with MPV_EVENT_COMMAND_REPLY."]
    #[doc = ""]
    #[doc = " @param reply_userdata ID of the request to be aborted (see above)"]
    pub fn mpv_abort_async_command(ctx: *mut mpv_handle, reply_userdata: u64);
}
extern "C" {
    #[doc = " Set a property to a given value. Properties are essentially variables which"]
    #[doc = " can be queried or set at runtime. For example, writing to the pause property"]
    #[doc = " will actually pause or unpause playback."]
    #[doc = ""]
    #[doc = " If the format doesn't match with the internal format of the property, access"]
    #[doc = " usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data"]
    #[doc = " is automatically converted and access succeeds. For example, MPV_FORMAT_INT64"]
    #[doc = " is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING"]
    #[doc = " usually invokes a string parser. The same happens when calling this function"]
    #[doc = " with MPV_FORMAT_NODE: the underlying format may be converted to another"]
    #[doc = " type if possible."]
    #[doc = ""]
    #[doc = " Using a format other than MPV_FORMAT_NODE is equivalent to constructing a"]
    #[doc = " mpv_node with the given format and data, and passing the mpv_node to this"]
    #[doc = " function. (Before API version 1.21, this was different.)"]
    #[doc = ""]
    #[doc = " Note: starting with mpv 0.21.0 (client API version 1.23), this can be used to"]
    #[doc = "       set options in general. It even can be used before mpv_initialize()"]
    #[doc = "       has been called. If called before mpv_initialize(), setting properties"]
    #[doc = "       not backed by options will result in MPV_ERROR_PROPERTY_UNAVAILABLE."]
    #[doc = "       In some cases, properties and options still conflict. In these cases,"]
    #[doc = "       mpv_set_property() accesses the options before mpv_initialize(), and"]
    #[doc = "       the properties after mpv_initialize(). These conflicts will be removed"]
    #[doc = "       in mpv 0.23.0. See mpv_set_option() for further remarks."]
    #[doc = ""]
    #[doc = " @param name The property name. See input.rst for a list of properties."]
    #[doc = " @param format see enum mpv_format."]
    #[doc = " @param[in] data Option value."]
    #[doc = " @return error code"]
    pub fn mpv_set_property(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convenience function to set a property to a string value."]
    #[doc = ""]
    #[doc = " This is like calling mpv_set_property() with MPV_FORMAT_STRING."]
    pub fn mpv_set_property_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a property asynchronously. You will receive the result of the operation"]
    #[doc = " as MPV_EVENT_SET_PROPERTY_REPLY event. The mpv_event.error field will contain"]
    #[doc = " the result status of the operation. Otherwise, this function is similar to"]
    #[doc = " mpv_set_property()."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param reply_userdata see section about asynchronous calls"]
    #[doc = " @param name The property name."]
    #[doc = " @param format see enum mpv_format."]
    #[doc = " @param[in] data Option value. The value will be copied by the function. It"]
    #[doc = "                 will never be modified by the client API."]
    #[doc = " @return error code if sending the request failed"]
    pub fn mpv_set_property_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the value of the given property."]
    #[doc = ""]
    #[doc = " If the format doesn't match with the internal format of the property, access"]
    #[doc = " usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data"]
    #[doc = " is automatically converted and access succeeds. For example, MPV_FORMAT_INT64"]
    #[doc = " is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING"]
    #[doc = " usually invokes a string formatter."]
    #[doc = ""]
    #[doc = " @param name The property name."]
    #[doc = " @param format see enum mpv_format."]
    #[doc = " @param[out] data Pointer to the variable holding the option value. On"]
    #[doc = "                  success, the variable will be set to a copy of the option"]
    #[doc = "                  value. For formats that require dynamic memory allocation,"]
    #[doc = "                  you can free the value with mpv_free() (strings) or"]
    #[doc = "                  mpv_free_node_contents() (MPV_FORMAT_NODE)."]
    #[doc = " @return error code"]
    pub fn mpv_get_property(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the value of the property with the given name as string. This is"]
    #[doc = " equivalent to mpv_get_property() with MPV_FORMAT_STRING."]
    #[doc = ""]
    #[doc = " See MPV_FORMAT_STRING for character encoding issues."]
    #[doc = ""]
    #[doc = " On error, NULL is returned. Use mpv_get_property() if you want fine-grained"]
    #[doc = " error reporting."]
    #[doc = ""]
    #[doc = " @param name The property name."]
    #[doc = " @return Property value, or NULL if the property can't be retrieved. Free"]
    #[doc = "         the string with mpv_free()."]
    pub fn mpv_get_property_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the property as \"OSD\" formatted string. This is the same as"]
    #[doc = " mpv_get_property_string, but using MPV_FORMAT_OSD_STRING."]
    #[doc = ""]
    #[doc = " @return Property value, or NULL if the property can't be retrieved. Free"]
    #[doc = "         the string with mpv_free()."]
    pub fn mpv_get_property_osd_string(
        ctx: *mut mpv_handle,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a property asynchronously. You will receive the result of the operation"]
    #[doc = " as well as the property data with the MPV_EVENT_GET_PROPERTY_REPLY event."]
    #[doc = " You should check the mpv_event.error field on the reply event."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param reply_userdata see section about asynchronous calls"]
    #[doc = " @param name The property name."]
    #[doc = " @param format see enum mpv_format."]
    #[doc = " @return error code if sending the request failed"]
    pub fn mpv_get_property_async(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a notification whenever the given property changes. You will receive"]
    #[doc = " updates as MPV_EVENT_PROPERTY_CHANGE. Note that this is not very precise:"]
    #[doc = " for some properties, it may not send updates even if the property changed."]
    #[doc = " This depends on the property, and it's a valid feature request to ask for"]
    #[doc = " better update handling of a specific property. (For some properties, like"]
    #[doc = " ``clock``, which shows the wall clock, this mechanism doesn't make too"]
    #[doc = " much sense anyway.)"]
    #[doc = ""]
    #[doc = " Property changes are coalesced: the change events are returned only once the"]
    #[doc = " event queue becomes empty (e.g. mpv_wait_event() would block or return"]
    #[doc = " MPV_EVENT_NONE), and then only one event per changed property is returned."]
    #[doc = ""]
    #[doc = " You always get an initial change notification. This is meant to initialize"]
    #[doc = " the user's state to the current value of the property."]
    #[doc = ""]
    #[doc = " Normally, change events are sent only if the property value changes according"]
    #[doc = " to the requested format. mpv_event_property will contain the property value"]
    #[doc = " as data member."]
    #[doc = ""]
    #[doc = " Warning: if a property is unavailable or retrieving it caused an error,"]
    #[doc = "          MPV_FORMAT_NONE will be set in mpv_event_property, even if the"]
    #[doc = "          format parameter was set to a different value. In this case, the"]
    #[doc = "          mpv_event_property.data field is invalid."]
    #[doc = ""]
    #[doc = " If the property is observed with the format parameter set to MPV_FORMAT_NONE,"]
    #[doc = " you get low-level notifications whether the property _may_ have changed, and"]
    #[doc = " the data member in mpv_event_property will be unset. With this mode, you"]
    #[doc = " will have to determine yourself whether the property really changed. On the"]
    #[doc = " other hand, this mechanism can be faster and uses less resources."]
    #[doc = ""]
    #[doc = " Observing a property that doesn't exist is allowed. (Although it may still"]
    #[doc = " cause some sporadic change events.)"]
    #[doc = ""]
    #[doc = " Keep in mind that you will get change notifications even if you change a"]
    #[doc = " property yourself. Try to avoid endless feedback loops, which could happen"]
    #[doc = " if you react to the change notifications triggered by your own change."]
    #[doc = ""]
    #[doc = " Only the mpv_handle on which this was called will receive the property"]
    #[doc = " change events, or can unobserve them."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param reply_userdata This will be used for the mpv_event.reply_userdata"]
    #[doc = "                       field for the received MPV_EVENT_PROPERTY_CHANGE"]
    #[doc = "                       events. (Also see section about asynchronous calls,"]
    #[doc = "                       although this function is somewhat different from"]
    #[doc = "                       actual asynchronous calls.)"]
    #[doc = "                       If you have no use for this, pass 0."]
    #[doc = "                       Also see mpv_unobserve_property()."]
    #[doc = " @param name The property name."]
    #[doc = " @param format see enum mpv_format. Can be MPV_FORMAT_NONE to omit values"]
    #[doc = "               from the change events."]
    #[doc = " @return error code (usually fails only on OOM or unsupported format)"]
    pub fn mpv_observe_property(
        mpv: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        format: mpv_format,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Undo mpv_observe_property(). This will remove all observed properties for"]
    #[doc = " which the given number was passed as reply_userdata to mpv_observe_property."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param registered_reply_userdata ID that was passed to mpv_observe_property"]
    #[doc = " @return negative value is an error code, >=0 is number of removed properties"]
    #[doc = "         on success (includes the case when 0 were removed)"]
    pub fn mpv_unobserve_property(
        mpv: *mut mpv_handle,
        registered_reply_userdata: u64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Nothing happened. Happens on timeouts or sporadic wakeups."]
pub const mpv_event_id_MPV_EVENT_NONE: mpv_event_id = 0;
#[doc = " Happens when the player quits. The player enters a state where it tries"]
#[doc = " to disconnect all clients. Most requests to the player will fail, and"]
#[doc = " the client should react to this and quit with mpv_destroy() as soon as"]
#[doc = " possible."]
pub const mpv_event_id_MPV_EVENT_SHUTDOWN: mpv_event_id = 1;
#[doc = " See mpv_request_log_messages()."]
pub const mpv_event_id_MPV_EVENT_LOG_MESSAGE: mpv_event_id = 2;
#[doc = " Reply to a mpv_get_property_async() request."]
#[doc = " See also mpv_event and mpv_event_property."]
pub const mpv_event_id_MPV_EVENT_GET_PROPERTY_REPLY: mpv_event_id = 3;
#[doc = " Reply to a mpv_set_property_async() request."]
#[doc = " (Unlike MPV_EVENT_GET_PROPERTY, mpv_event_property is not used.)"]
pub const mpv_event_id_MPV_EVENT_SET_PROPERTY_REPLY: mpv_event_id = 4;
#[doc = " Reply to a mpv_command_async() or mpv_command_node_async() request."]
#[doc = " See also mpv_event and mpv_event_command."]
pub const mpv_event_id_MPV_EVENT_COMMAND_REPLY: mpv_event_id = 5;
#[doc = " Notification before playback start of a file (before the file is loaded)."]
#[doc = " See also mpv_event and mpv_event_start_file."]
pub const mpv_event_id_MPV_EVENT_START_FILE: mpv_event_id = 6;
#[doc = " Notification after playback end (after the file was unloaded)."]
#[doc = " See also mpv_event and mpv_event_end_file."]
pub const mpv_event_id_MPV_EVENT_END_FILE: mpv_event_id = 7;
#[doc = " Notification when the file has been loaded (headers were read etc.), and"]
#[doc = " decoding starts."]
pub const mpv_event_id_MPV_EVENT_FILE_LOADED: mpv_event_id = 8;
#[doc = " Idle mode was entered. In this mode, no file is played, and the playback"]
#[doc = " core waits for new commands. (The command line player normally quits"]
#[doc = " instead of entering idle mode, unless --idle was specified. If mpv"]
#[doc = " was started with mpv_create(), idle mode is enabled by default.)"]
#[doc = ""]
#[doc = " @deprecated This is equivalent to using mpv_observe_property() on the"]
#[doc = "             \"idle-active\" property. The event is redundant, and might be"]
#[doc = "             removed in the far future. As a further warning, this event"]
#[doc = "             is not necessarily sent at the right point anymore (at the"]
#[doc = "             start of the program), while the property behaves correctly."]
pub const mpv_event_id_MPV_EVENT_IDLE: mpv_event_id = 11;
#[doc = " Sent every time after a video frame is displayed. Note that currently,"]
#[doc = " this will be sent in lower frequency if there is no video, or playback"]
#[doc = " is paused - but that will be removed in the future, and it will be"]
#[doc = " restricted to video frames only."]
#[doc = ""]
#[doc = " @deprecated Use mpv_observe_property() with relevant properties instead"]
#[doc = "             (such as \"playback-time\")."]
pub const mpv_event_id_MPV_EVENT_TICK: mpv_event_id = 14;
#[doc = " Triggered by the script-message input command. The command uses the"]
#[doc = " first argument of the command as client name (see mpv_client_name()) to"]
#[doc = " dispatch the message, and passes along all arguments starting from the"]
#[doc = " second argument as strings."]
#[doc = " See also mpv_event and mpv_event_client_message."]
pub const mpv_event_id_MPV_EVENT_CLIENT_MESSAGE: mpv_event_id = 16;
#[doc = " Happens after video changed in some way. This can happen on resolution"]
#[doc = " changes, pixel format changes, or video filter changes. The event is"]
#[doc = " sent after the video filters and the VO are reconfigured. Applications"]
#[doc = " embedding a mpv window should listen to this event in order to resize"]
#[doc = " the window if needed."]
#[doc = " Note that this event can happen sporadically, and you should check"]
#[doc = " yourself whether the video parameters really changed before doing"]
#[doc = " something expensive."]
pub const mpv_event_id_MPV_EVENT_VIDEO_RECONFIG: mpv_event_id = 17;
#[doc = " Similar to MPV_EVENT_VIDEO_RECONFIG. This is relatively uninteresting,"]
#[doc = " because there is no such thing as audio output embedding."]
pub const mpv_event_id_MPV_EVENT_AUDIO_RECONFIG: mpv_event_id = 18;
#[doc = " Happens when a seek was initiated. Playback stops. Usually it will"]
#[doc = " resume with MPV_EVENT_PLAYBACK_RESTART as soon as the seek is finished."]
pub const mpv_event_id_MPV_EVENT_SEEK: mpv_event_id = 20;
#[doc = " There was a discontinuity of some sort (like a seek), and playback"]
#[doc = " was reinitialized. Usually happens on start of playback and after"]
#[doc = " seeking. The main purpose is allowing the client to detect when a seek"]
#[doc = " request is finished."]
pub const mpv_event_id_MPV_EVENT_PLAYBACK_RESTART: mpv_event_id = 21;
#[doc = " Event sent due to mpv_observe_property()."]
#[doc = " See also mpv_event and mpv_event_property."]
pub const mpv_event_id_MPV_EVENT_PROPERTY_CHANGE: mpv_event_id = 22;
#[doc = " Happens if the internal per-mpv_handle ringbuffer overflows, and at"]
#[doc = " least 1 event had to be dropped. This can happen if the client doesn't"]
#[doc = " read the event queue quickly enough with mpv_wait_event(), or if the"]
#[doc = " client makes a very large number of asynchronous calls at once."]
#[doc = ""]
#[doc = " Event delivery will continue normally once this event was returned"]
#[doc = " (this forces the client to empty the queue completely)."]
pub const mpv_event_id_MPV_EVENT_QUEUE_OVERFLOW: mpv_event_id = 24;
#[doc = " Triggered if a hook handler was registered with mpv_hook_add(), and the"]
#[doc = " hook is invoked. If you receive this, you must handle it, and continue"]
#[doc = " the hook with mpv_hook_continue()."]
#[doc = " See also mpv_event and mpv_event_hook."]
pub const mpv_event_id_MPV_EVENT_HOOK: mpv_event_id = 25;
pub type mpv_event_id = u32;
extern "C" {
    #[doc = " Return a string describing the event. For unknown events, NULL is returned."]
    #[doc = ""]
    #[doc = " Note that all events actually returned by the API will also yield a non-NULL"]
    #[doc = " string with this function."]
    #[doc = ""]
    #[doc = " @param event event ID, see see enum mpv_event_id"]
    #[doc = " @return A static string giving a short symbolic name of the event. It"]
    #[doc = "         consists of lower-case alphanumeric characters and can include \"-\""]
    #[doc = "         characters. This string is suitable for use in e.g. scripting"]
    #[doc = "         interfaces."]
    #[doc = "         The string is completely static, i.e. doesn't need to be deallocated,"]
    #[doc = "         and is valid forever."]
    pub fn mpv_event_name(event: mpv_event_id) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_property {
    #[doc = " Name of the property."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Format of the data field in the same struct. See enum mpv_format."]
    #[doc = " This is always the same format as the requested format, except when"]
    #[doc = " the property could not be retrieved (unavailable, or an error happened),"]
    #[doc = " in which case the format is MPV_FORMAT_NONE."]
    pub format: mpv_format,
    #[doc = " Received property value. Depends on the format. This is like the"]
    #[doc = " pointer argument passed to mpv_get_property()."]
    #[doc = ""]
    #[doc = " For example, for MPV_FORMAT_STRING you get the string with:"]
    #[doc = ""]
    #[doc = "    char *value = *(char **)(event_property->data);"]
    #[doc = ""]
    #[doc = " Note that this is set to NULL if retrieving the property failed (the"]
    #[doc = " format will be MPV_FORMAT_NONE)."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mpv_event_property() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_property>(),
        24usize,
        concat!("Size of: ", stringify!(mpv_event_property))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_property>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_property))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_property>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_property>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_property),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_property>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_property),
            "::",
            stringify!(data)
        )
    );
}
pub const mpv_log_level_MPV_LOG_LEVEL_NONE: mpv_log_level = 0;
#[doc = " \"no\"    - disable absolutely all messages"]
pub const mpv_log_level_MPV_LOG_LEVEL_FATAL: mpv_log_level = 10;
#[doc = " \"fatal\" - critical/aborting errors"]
pub const mpv_log_level_MPV_LOG_LEVEL_ERROR: mpv_log_level = 20;
#[doc = " \"error\" - simple errors"]
pub const mpv_log_level_MPV_LOG_LEVEL_WARN: mpv_log_level = 30;
#[doc = " \"warn\"  - possible problems"]
pub const mpv_log_level_MPV_LOG_LEVEL_INFO: mpv_log_level = 40;
#[doc = " \"info\"  - informational message"]
pub const mpv_log_level_MPV_LOG_LEVEL_V: mpv_log_level = 50;
#[doc = " \"v\"     - noisy informational message"]
pub const mpv_log_level_MPV_LOG_LEVEL_DEBUG: mpv_log_level = 60;
#[doc = " \"debug\" - very noisy technical information"]
pub const mpv_log_level_MPV_LOG_LEVEL_TRACE: mpv_log_level = 70;
#[doc = " Numeric log levels. The lower the number, the more important the message is."]
#[doc = " MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in"]
#[doc = " the comment after the value is the name of the log level as used for the"]
#[doc = " mpv_request_log_messages() function."]
#[doc = " Unused numeric values are unused, but reserved for future use."]
pub type mpv_log_level = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_log_message {
    #[doc = " The module prefix, identifies the sender of the message. As a special"]
    #[doc = " case, if the message buffer overflows, this will be set to the string"]
    #[doc = " \"overflow\" (which doesn't appear as prefix otherwise), and the text"]
    #[doc = " field will contain an informative message."]
    pub prefix: *const ::std::os::raw::c_char,
    #[doc = " The log level as string. See mpv_request_log_messages() for possible"]
    #[doc = " values. The level \"no\" is never used here."]
    pub level: *const ::std::os::raw::c_char,
    #[doc = " The log message. It consists of 1 line of text, and is terminated with"]
    #[doc = " a newline character. (Before API version 1.6, it could contain multiple"]
    #[doc = " or partial lines.)"]
    pub text: *const ::std::os::raw::c_char,
    #[doc = " The same contents as the level field, but as a numeric ID."]
    #[doc = " Since API version 1.6."]
    pub log_level: mpv_log_level,
}
#[test]
fn bindgen_test_layout_mpv_event_log_message() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_log_message>(),
        32usize,
        concat!("Size of: ", stringify!(mpv_event_log_message))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_log_message>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_log_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_log_message>())).prefix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_log_message),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_log_message>())).level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_log_message),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_log_message>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_log_message),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_log_message>())).log_level as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_log_message),
            "::",
            stringify!(log_level)
        )
    );
}
#[doc = " The end of file was reached. Sometimes this may also happen on"]
#[doc = " incomplete or corrupted files, or if the network connection was"]
#[doc = " interrupted when playing a remote file. It also happens if the"]
#[doc = " playback range was restricted with --end or --frames or similar."]
pub const mpv_end_file_reason_MPV_END_FILE_REASON_EOF: mpv_end_file_reason = 0;
#[doc = " Playback was stopped by an external action (e.g. playlist controls)."]
pub const mpv_end_file_reason_MPV_END_FILE_REASON_STOP: mpv_end_file_reason = 2;
#[doc = " Playback was stopped by the quit command or player shutdown."]
pub const mpv_end_file_reason_MPV_END_FILE_REASON_QUIT: mpv_end_file_reason = 3;
#[doc = " Some kind of error happened that lead to playback abort. Does not"]
#[doc = " necessarily happen on incomplete or broken files (in these cases, both"]
#[doc = " MPV_END_FILE_REASON_ERROR or MPV_END_FILE_REASON_EOF are possible)."]
#[doc = ""]
#[doc = " mpv_event_end_file.error will be set."]
pub const mpv_end_file_reason_MPV_END_FILE_REASON_ERROR: mpv_end_file_reason = 4;
#[doc = " The file was a playlist or similar. When the playlist is read, its"]
#[doc = " entries will be appended to the playlist after the entry of the current"]
#[doc = " file, the entry of the current file is removed, and a MPV_EVENT_END_FILE"]
#[doc = " event is sent with reason set to MPV_END_FILE_REASON_REDIRECT. Then"]
#[doc = " playback continues with the playlist contents."]
#[doc = " Since API version 1.18."]
pub const mpv_end_file_reason_MPV_END_FILE_REASON_REDIRECT: mpv_end_file_reason = 5;
#[doc = " Since API version 1.9."]
pub type mpv_end_file_reason = u32;
#[doc = " Since API version 1.108."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_start_file {
    #[doc = " Playlist entry ID of the file being loaded now."]
    pub playlist_entry_id: i64,
}
#[test]
fn bindgen_test_layout_mpv_event_start_file() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_start_file>(),
        8usize,
        concat!("Size of: ", stringify!(mpv_event_start_file))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_start_file>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_start_file))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_event_start_file>())).playlist_entry_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_start_file),
            "::",
            stringify!(playlist_entry_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_end_file {
    #[doc = " Corresponds to the values in enum mpv_end_file_reason."]
    #[doc = ""]
    #[doc = " Unknown values should be treated as unknown."]
    pub reason: mpv_end_file_reason,
    #[doc = " If reason==MPV_END_FILE_REASON_ERROR, this contains a mpv error code"]
    #[doc = " (one of MPV_ERROR_...) giving an approximate reason why playback"]
    #[doc = " failed. In other cases, this field is 0 (no error)."]
    #[doc = " Since API version 1.9."]
    pub error: ::std::os::raw::c_int,
    #[doc = " Playlist entry ID of the file that was being played or attempted to be"]
    #[doc = " played. This has the same value as the playlist_entry_id field in the"]
    #[doc = " corresponding mpv_event_start_file event."]
    #[doc = " Since API version 1.108."]
    pub playlist_entry_id: i64,
    #[doc = " If loading ended, because the playlist entry to be played was for example"]
    #[doc = " a playlist, and the current playlist entry is replaced with a number of"]
    #[doc = " other entries. This may happen at least with MPV_END_FILE_REASON_REDIRECT"]
    #[doc = " (other event types may use this for similar but different purposes in the"]
    #[doc = " future). In this case, playlist_insert_id will be set to the playlist"]
    #[doc = " entry ID of the first inserted entry, and playlist_insert_num_entries to"]
    #[doc = " the total number of inserted playlist entries. Note this in this specific"]
    #[doc = " case, the ID of the last inserted entry is playlist_insert_id+num-1."]
    #[doc = " Beware that depending on circumstances, you may observe the new playlist"]
    #[doc = " entries before seeing the event (e.g. reading the \"playlist\" property or"]
    #[doc = " getting a property change notification before receiving the event)."]
    #[doc = " Since API version 1.108."]
    pub playlist_insert_id: i64,
    #[doc = " See playlist_insert_id. Only non-0 if playlist_insert_id is valid. Never"]
    #[doc = " negative."]
    #[doc = " Since API version 1.108."]
    pub playlist_insert_num_entries: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mpv_event_end_file() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_end_file>(),
        32usize,
        concat!("Size of: ", stringify!(mpv_event_end_file))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_end_file>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_end_file))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_end_file>())).reason as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_end_file),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_end_file>())).error as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_end_file),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_event_end_file>())).playlist_entry_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_end_file),
            "::",
            stringify!(playlist_entry_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_event_end_file>())).playlist_insert_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_end_file),
            "::",
            stringify!(playlist_insert_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_event_end_file>())).playlist_insert_num_entries as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_end_file),
            "::",
            stringify!(playlist_insert_num_entries)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_client_message {
    #[doc = " Arbitrary arguments chosen by the sender of the message. If num_args > 0,"]
    #[doc = " you can access args[0] through args[num_args - 1] (inclusive). What"]
    #[doc = " these arguments mean is up to the sender and receiver."]
    #[doc = " None of the valid items are NULL."]
    pub num_args: ::std::os::raw::c_int,
    pub args: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mpv_event_client_message() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_client_message>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_event_client_message))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_client_message>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_client_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_event_client_message>())).num_args as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_client_message),
            "::",
            stringify!(num_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_client_message>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_client_message),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event_hook {
    #[doc = " The hook name as passed to mpv_hook_add()."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Internal ID that must be passed to mpv_hook_continue()."]
    pub id: u64,
}
#[test]
fn bindgen_test_layout_mpv_event_hook() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_hook>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_event_hook))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_hook>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_hook))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_hook>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_hook),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_hook>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_hook),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpv_event_command {
    #[doc = " Result data of the command. Note that success/failure is signaled"]
    #[doc = " separately via mpv_event.error. This field is only for result data"]
    #[doc = " in case of success. Most commands leave it at MPV_FORMAT_NONE. Set"]
    #[doc = " to MPV_FORMAT_NONE on failure."]
    pub result: mpv_node,
}
#[test]
fn bindgen_test_layout_mpv_event_command() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event_command>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_event_command))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event_command>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event_command))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event_command>())).result as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event_command),
            "::",
            stringify!(result)
        )
    );
}
impl ::std::fmt::Debug for mpv_event_command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "mpv_event_command {{ result: {:?} }}", self.result)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_event {
    #[doc = " One of mpv_event. Keep in mind that later ABI compatible releases might"]
    #[doc = " add new event types. These should be ignored by the API user."]
    pub event_id: mpv_event_id,
    #[doc = " This is mainly used for events that are replies to (asynchronous)"]
    #[doc = " requests. It contains a status code, which is >= 0 on success, or < 0"]
    #[doc = " on error (a mpv_error value). Usually, this will be set if an"]
    #[doc = " asynchronous request fails."]
    #[doc = " Used for:"]
    #[doc = "  MPV_EVENT_GET_PROPERTY_REPLY"]
    #[doc = "  MPV_EVENT_SET_PROPERTY_REPLY"]
    #[doc = "  MPV_EVENT_COMMAND_REPLY"]
    pub error: ::std::os::raw::c_int,
    #[doc = " If the event is in reply to a request (made with this API and this"]
    #[doc = " API handle), this is set to the reply_userdata parameter of the request"]
    #[doc = " call. Otherwise, this field is 0."]
    #[doc = " Used for:"]
    #[doc = "  MPV_EVENT_GET_PROPERTY_REPLY"]
    #[doc = "  MPV_EVENT_SET_PROPERTY_REPLY"]
    #[doc = "  MPV_EVENT_COMMAND_REPLY"]
    #[doc = "  MPV_EVENT_PROPERTY_CHANGE"]
    #[doc = "  MPV_EVENT_HOOK"]
    pub reply_userdata: u64,
    #[doc = " The meaning and contents of the data member depend on the event_id:"]
    #[doc = "  MPV_EVENT_GET_PROPERTY_REPLY:     mpv_event_property*"]
    #[doc = "  MPV_EVENT_PROPERTY_CHANGE:        mpv_event_property*"]
    #[doc = "  MPV_EVENT_LOG_MESSAGE:            mpv_event_log_message*"]
    #[doc = "  MPV_EVENT_CLIENT_MESSAGE:         mpv_event_client_message*"]
    #[doc = "  MPV_EVENT_START_FILE:             mpv_event_start_file* (since v1.108)"]
    #[doc = "  MPV_EVENT_END_FILE:               mpv_event_end_file*"]
    #[doc = "  MPV_EVENT_HOOK:                   mpv_event_hook*"]
    #[doc = "  MPV_EVENT_COMMAND_REPLY*          mpv_event_command*"]
    #[doc = "  other: NULL"]
    #[doc = ""]
    #[doc = " Note: future enhancements might add new event structs for existing or new"]
    #[doc = "       event types."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mpv_event() {
    assert_eq!(
        ::std::mem::size_of::<mpv_event>(),
        24usize,
        concat!("Size of: ", stringify!(mpv_event))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_event>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event>())).event_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event),
            "::",
            stringify!(event_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event>())).error as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event>())).reply_userdata as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event),
            "::",
            stringify!(reply_userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_event>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_event),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Convert the given src event to a mpv_node, and set *dst to the result. *dst"]
    #[doc = " is set to a MPV_FORMAT_NODE_MAP, with fields for corresponding mpv_event and"]
    #[doc = " mpv_event.data/mpv_event_* fields."]
    #[doc = ""]
    #[doc = " The exact details are not completely documented out of laziness. A start"]
    #[doc = " is located in the \"Events\" section of the manpage."]
    #[doc = ""]
    #[doc = " *dst may point to newly allocated memory, or pointers in mpv_event. You must"]
    #[doc = " copy the entire mpv_node if you want to reference it after mpv_event becomes"]
    #[doc = " invalid (such as making a new mpv_wait_event() call, or destroying the"]
    #[doc = " mpv_handle from which it was returned). Call mpv_free_node_contents() to free"]
    #[doc = " any memory allocations made by this API function."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param dst Target. This is not read and fully overwritten. Must be released"]
    #[doc = "            with mpv_free_node_contents(). Do not write to pointers returned"]
    #[doc = "            by it. (On error, this may be left as an empty node.)"]
    #[doc = " @param src The source event. Not modified (it's not const due to the author's"]
    #[doc = "            prejudice of the C version of const)."]
    #[doc = " @return error code (MPV_ERROR_NOMEM only, if at all)"]
    pub fn mpv_event_to_node(dst: *mut mpv_node, src: *mut mpv_event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable the given event."]
    #[doc = ""]
    #[doc = " Some events are enabled by default. Some events can't be disabled."]
    #[doc = ""]
    #[doc = " (Informational note: currently, all events are enabled by default, except"]
    #[doc = "  MPV_EVENT_TICK.)"]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    #[doc = ""]
    #[doc = " @param event See enum mpv_event_id."]
    #[doc = " @param enable 1 to enable receiving this event, 0 to disable it."]
    #[doc = " @return error code"]
    pub fn mpv_request_event(
        ctx: *mut mpv_handle,
        event: mpv_event_id,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable receiving of log messages. These are the messages the"]
    #[doc = " command line player prints to the terminal. This call sets the minimum"]
    #[doc = " required log level for a message to be received with MPV_EVENT_LOG_MESSAGE."]
    #[doc = ""]
    #[doc = " @param min_level Minimal log level as string. Valid log levels:"]
    #[doc = "                      no fatal error warn info v debug trace"]
    #[doc = "                  The value \"no\" disables all messages. This is the default."]
    #[doc = "                  An exception is the value \"terminal-default\", which uses the"]
    #[doc = "                  log level as set by the \"--msg-level\" option. This works"]
    #[doc = "                  even if the terminal is disabled. (Since API version 1.19.)"]
    #[doc = "                  Also see mpv_log_level."]
    #[doc = " @return error code"]
    pub fn mpv_request_log_messages(
        ctx: *mut mpv_handle,
        min_level: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for the next event, or until the timeout expires, or if another thread"]
    #[doc = " makes a call to mpv_wakeup(). Passing 0 as timeout will never wait, and"]
    #[doc = " is suitable for polling."]
    #[doc = ""]
    #[doc = " The internal event queue has a limited size (per client handle). If you"]
    #[doc = " don't empty the event queue quickly enough with mpv_wait_event(), it will"]
    #[doc = " overflow and silently discard further events. If this happens, making"]
    #[doc = " asynchronous requests will fail as well (with MPV_ERROR_EVENT_QUEUE_FULL)."]
    #[doc = ""]
    #[doc = " Only one thread is allowed to call this on the same mpv_handle at a time."]
    #[doc = " The API won't complain if more than one thread calls this, but it will cause"]
    #[doc = " race conditions in the client when accessing the shared mpv_event struct."]
    #[doc = " Note that most other API functions are not restricted by this, and no API"]
    #[doc = " function internally calls mpv_wait_event(). Additionally, concurrent calls"]
    #[doc = " to different mpv_handles are always safe."]
    #[doc = ""]
    #[doc = " As long as the timeout is 0, this is safe to be called from mpv render API"]
    #[doc = " threads."]
    #[doc = ""]
    #[doc = " @param timeout Timeout in seconds, after which the function returns even if"]
    #[doc = "                no event was received. A MPV_EVENT_NONE is returned on"]
    #[doc = "                timeout. A value of 0 will disable waiting. Negative values"]
    #[doc = "                will wait with an infinite timeout."]
    #[doc = " @return A struct containing the event ID and other data. The pointer (and"]
    #[doc = "         fields in the struct) stay valid until the next mpv_wait_event()"]
    #[doc = "         call, or until the mpv_handle is destroyed. You must not write to"]
    #[doc = "         the struct, and all memory referenced by it will be automatically"]
    #[doc = "         released by the API on the next mpv_wait_event() call, or when the"]
    #[doc = "         context is destroyed. The return value is never NULL."]
    pub fn mpv_wait_event(ctx: *mut mpv_handle, timeout: f64) -> *mut mpv_event;
}
extern "C" {
    #[doc = " Interrupt the current mpv_wait_event() call. This will wake up the thread"]
    #[doc = " currently waiting in mpv_wait_event(). If no thread is waiting, the next"]
    #[doc = " mpv_wait_event() call will return immediately (this is to avoid lost"]
    #[doc = " wakeups)."]
    #[doc = ""]
    #[doc = " mpv_wait_event() will receive a MPV_EVENT_NONE if it's woken up due to"]
    #[doc = " this call. But note that this dummy event might be skipped if there are"]
    #[doc = " already other events queued. All what counts is that the waiting thread"]
    #[doc = " is woken up at all."]
    #[doc = ""]
    #[doc = " Safe to be called from mpv render API threads."]
    pub fn mpv_wakeup(ctx: *mut mpv_handle);
}
extern "C" {
    #[doc = " Set a custom function that should be called when there are new events. Use"]
    #[doc = " this if blocking in mpv_wait_event() to wait for new events is not feasible."]
    #[doc = ""]
    #[doc = " Keep in mind that the callback will be called from foreign threads. You"]
    #[doc = " must not make any assumptions of the environment, and you must return as"]
    #[doc = " soon as possible (i.e. no long blocking waits). Exiting the callback through"]
    #[doc = " any other means than a normal return is forbidden (no throwing exceptions,"]
    #[doc = " no longjmp() calls). You must not change any local thread state (such as"]
    #[doc = " the C floating point environment)."]
    #[doc = ""]
    #[doc = " You are not allowed to call any client API functions inside of the callback."]
    #[doc = " In particular, you should not do any processing in the callback, but wake up"]
    #[doc = " another thread that does all the work. The callback is meant strictly for"]
    #[doc = " notification only, and is called from arbitrary core parts of the player,"]
    #[doc = " that make no considerations for reentrant API use or allowing the callee to"]
    #[doc = " spend a lot of time doing other things. Keep in mind that it's also possible"]
    #[doc = " that the callback is called from a thread while a mpv API function is called"]
    #[doc = " (i.e. it can be reentrant)."]
    #[doc = ""]
    #[doc = " In general, the client API expects you to call mpv_wait_event() to receive"]
    #[doc = " notifications, and the wakeup callback is merely a helper utility to make"]
    #[doc = " this easier in certain situations. Note that it's possible that there's"]
    #[doc = " only one wakeup callback invocation for multiple events. You should call"]
    #[doc = " mpv_wait_event() with no timeout until MPV_EVENT_NONE is reached, at which"]
    #[doc = " point the event queue is empty."]
    #[doc = ""]
    #[doc = " If you actually want to do processing in a callback, spawn a thread that"]
    #[doc = " does nothing but call mpv_wait_event() in a loop and dispatches the result"]
    #[doc = " to a callback."]
    #[doc = ""]
    #[doc = " Only one wakeup callback can be set."]
    #[doc = ""]
    #[doc = " @param cb function that should be called if a wakeup is required"]
    #[doc = " @param d arbitrary userdata passed to cb"]
    pub fn mpv_set_wakeup_callback(
        ctx: *mut mpv_handle,
        cb: ::std::option::Option<unsafe extern "C" fn(d: *mut ::std::os::raw::c_void)>,
        d: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Block until all asynchronous requests are done. This affects functions like"]
    #[doc = " mpv_command_async(), which return immediately and return their result as"]
    #[doc = " events."]
    #[doc = ""]
    #[doc = " This is a helper, and somewhat equivalent to calling mpv_wait_event() in a"]
    #[doc = " loop until all known asynchronous requests have sent their reply as event,"]
    #[doc = " except that the event queue is not emptied."]
    #[doc = ""]
    #[doc = " In case you called mpv_suspend() before, this will also forcibly reset the"]
    #[doc = " suspend counter of the given handle."]
    pub fn mpv_wait_async_requests(ctx: *mut mpv_handle);
}
extern "C" {
    #[doc = " A hook is like a synchronous event that blocks the player. You register"]
    #[doc = " a hook handler with this function. You will get an event, which you need"]
    #[doc = " to handle, and once things are ready, you can let the player continue with"]
    #[doc = " mpv_hook_continue()."]
    #[doc = ""]
    #[doc = " Currently, hooks can't be removed explicitly. But they will be implicitly"]
    #[doc = " removed if the mpv_handle it was registered with is destroyed. This also"]
    #[doc = " continues the hook if it was being handled by the destroyed mpv_handle (but"]
    #[doc = " this should be avoided, as it might mess up order of hook execution)."]
    #[doc = ""]
    #[doc = " Hook handlers are ordered globally by priority and order of registration."]
    #[doc = " Handlers for the same hook with same priority are invoked in order of"]
    #[doc = " registration (the handler registered first is run first). Handlers with"]
    #[doc = " lower priority are run first (which seems backward)."]
    #[doc = ""]
    #[doc = " See the \"Hooks\" section in the manpage to see which hooks are currently"]
    #[doc = " defined."]
    #[doc = ""]
    #[doc = " Some hooks might be reentrant (so you get multiple MPV_EVENT_HOOK for the"]
    #[doc = " same hook). If this can happen for a specific hook type, it will be"]
    #[doc = " explicitly documented in the manpage."]
    #[doc = ""]
    #[doc = " Only the mpv_handle on which this was called will receive the hook events,"]
    #[doc = " or can \"continue\" them."]
    #[doc = ""]
    #[doc = " @param reply_userdata This will be used for the mpv_event.reply_userdata"]
    #[doc = "                       field for the received MPV_EVENT_HOOK events."]
    #[doc = "                       If you have no use for this, pass 0."]
    #[doc = " @param name The hook name. This should be one of the documented names. But"]
    #[doc = "             if the name is unknown, the hook event will simply be never"]
    #[doc = "             raised."]
    #[doc = " @param priority See remarks above. Use 0 as a neutral default."]
    #[doc = " @return error code (usually fails only on OOM)"]
    pub fn mpv_hook_add(
        ctx: *mut mpv_handle,
        reply_userdata: u64,
        name: *const ::std::os::raw::c_char,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Respond to a MPV_EVENT_HOOK event. You must call this after you have handled"]
    #[doc = " the event. There is no way to \"cancel\" or \"stop\" the hook."]
    #[doc = ""]
    #[doc = " Calling this will will typically unblock the player for whatever the hook"]
    #[doc = " is responsible for (e.g. for the \"on_load\" hook it lets it continue"]
    #[doc = " playback)."]
    #[doc = ""]
    #[doc = " It is explicitly undefined behavior to call this more than once for each"]
    #[doc = " MPV_EVENT_HOOK, to pass an incorrect ID, or to call this on a mpv_handle"]
    #[doc = " different from the one that registered the handler and received the event."]
    #[doc = ""]
    #[doc = " @param id This must be the value of the mpv_event_hook.id field for the"]
    #[doc = "           corresponding MPV_EVENT_HOOK."]
    #[doc = " @return error code"]
    pub fn mpv_hook_continue(ctx: *mut mpv_handle, id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a UNIX file descriptor referring to the read end of a pipe. This"]
    #[doc = " pipe can be used to wake up a poll() based processing loop. The purpose of"]
    #[doc = " this function is very similar to mpv_set_wakeup_callback(), and provides"]
    #[doc = " a primitive mechanism to handle coordinating a foreign event loop and the"]
    #[doc = " libmpv event loop. The pipe is non-blocking. It's closed when the mpv_handle"]
    #[doc = " is destroyed. This function always returns the same value (on success)."]
    #[doc = ""]
    #[doc = " This is in fact implemented using the same underlying code as for"]
    #[doc = " mpv_set_wakeup_callback() (though they don't conflict), and it is as if each"]
    #[doc = " callback invocation writes a single 0 byte to the pipe. When the pipe"]
    #[doc = " becomes readable, the code calling poll() (or select()) on the pipe should"]
    #[doc = " read all contents of the pipe and then call mpv_wait_event(c, 0) until"]
    #[doc = " no new events are returned. The pipe contents do not matter and can just"]
    #[doc = " be discarded. There is not necessarily one byte per readable event in the"]
    #[doc = " pipe. For example, the pipes are non-blocking, and mpv won't block if the"]
    #[doc = " pipe is full. Pipes are normally limited to 4096 bytes, so if there are"]
    #[doc = " more than 4096 events, the number of readable bytes can not equal the number"]
    #[doc = " of events queued. Also, it's possible that mpv does not write to the pipe"]
    #[doc = " once it's guaranteed that the client was already signaled. See the example"]
    #[doc = " below how to do it correctly."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = "  int pipefd = mpv_get_wakeup_pipe(mpv);"]
    #[doc = "  if (pipefd < 0)"]
    #[doc = "      error();"]
    #[doc = "  while (1) {"]
    #[doc = "      struct pollfd pfds[1] = {"]
    #[doc = "          { .fd = pipefd, .events = POLLIN },"]
    #[doc = "      };"]
    #[doc = "      // Wait until there are possibly new mpv events."]
    #[doc = "      poll(pfds, 1, -1);"]
    #[doc = "      if (pfds[0].revents & POLLIN) {"]
    #[doc = "          // Empty the pipe. Doing this before calling mpv_wait_event()"]
    #[doc = "          // ensures that no wakeups are missed. It's not so important to"]
    #[doc = "          // make sure the pipe is really empty (it will just cause some"]
    #[doc = "          // additional wakeups in unlikely corner cases)."]
    #[doc = "          char unused[256];"]
    #[doc = "          read(pipefd, unused, sizeof(unused));"]
    #[doc = "          while (1) {"]
    #[doc = "              mpv_event *ev = mpv_wait_event(mpv, 0);"]
    #[doc = "              // If MPV_EVENT_NONE is received, the event queue is empty."]
    #[doc = "              if (ev->event_id == MPV_EVENT_NONE)"]
    #[doc = "                  break;"]
    #[doc = "              // Process the event."]
    #[doc = "              ..."]
    #[doc = "          }"]
    #[doc = "      }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = " @deprecated this function will be removed in the future. If you need this"]
    #[doc = "             functionality, use mpv_set_wakeup_callback(), create a pipe"]
    #[doc = "             manually, and call write() on your pipe in the callback."]
    #[doc = ""]
    #[doc = " @return A UNIX FD of the read end of the wakeup pipe, or -1 on error."]
    #[doc = "         On MS Windows/MinGW, this will always return -1."]
    pub fn mpv_get_wakeup_pipe(ctx: *mut mpv_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_render_context {
    _unused: [u8; 0],
}
#[doc = " Not a valid value, but also used to terminate a params array. Its value"]
#[doc = " is always guaranteed to be 0 (even if the ABI changes in the future)."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_INVALID: mpv_render_param_type = 0;
#[doc = " The render API to use. Valid for mpv_render_context_create()."]
#[doc = ""]
#[doc = " Type: char*"]
#[doc = ""]
#[doc = " Defined APIs:"]
#[doc = ""]
#[doc = "   MPV_RENDER_API_TYPE_OPENGL:"]
#[doc = "      OpenGL desktop 2.1 or later (preferably core profile compatible to"]
#[doc = "      OpenGL 3.2), or OpenGLES 2.0 or later."]
#[doc = "      Providing MPV_RENDER_PARAM_OPENGL_INIT_PARAMS is required."]
#[doc = "      It is expected that an OpenGL context is valid and \"current\" when"]
#[doc = "      calling mpv_render_* functions (unless specified otherwise). It"]
#[doc = "      must be the same context for the same mpv_render_context."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_API_TYPE: mpv_render_param_type = 1;
#[doc = " Required parameters for initializing the OpenGL renderer. Valid for"]
#[doc = " mpv_render_context_create()."]
#[doc = " Type: mpv_opengl_init_params*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_OPENGL_INIT_PARAMS: mpv_render_param_type = 2;
#[doc = " Describes a GL render target. Valid for mpv_render_context_render()."]
#[doc = " Type: mpv_opengl_fbo*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_OPENGL_FBO: mpv_render_param_type = 3;
#[doc = " Control flipped rendering. Valid for mpv_render_context_render()."]
#[doc = " Type: int*"]
#[doc = " If the value is set to 0, render normally. Otherwise, render it flipped,"]
#[doc = " which is needed e.g. when rendering to an OpenGL default framebuffer"]
#[doc = " (which has a flipped coordinate system)."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_FLIP_Y: mpv_render_param_type = 4;
#[doc = " Control surface depth. Valid for mpv_render_context_render()."]
#[doc = " Type: int*"]
#[doc = " This implies the depth of the surface passed to the render function in"]
#[doc = " bits per channel. If omitted or set to 0, the renderer will assume 8."]
#[doc = " Typically used to control dithering."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_DEPTH: mpv_render_param_type = 5;
#[doc = " ICC profile blob. Valid for mpv_render_context_set_parameter()."]
#[doc = " Type: mpv_byte_array*"]
#[doc = " Set an ICC profile for use with the \"icc-profile-auto\" option. (If the"]
#[doc = " option is not enabled, the ICC data will not be used.)"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_ICC_PROFILE: mpv_render_param_type = 6;
#[doc = " Ambient light in lux. Valid for mpv_render_context_set_parameter()."]
#[doc = " Type: int*"]
#[doc = " This can be used for automatic gamma correction."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_AMBIENT_LIGHT: mpv_render_param_type = 7;
#[doc = " X11 Display, sometimes used for hwdec. Valid for"]
#[doc = " mpv_render_context_create(). The Display must stay valid for the lifetime"]
#[doc = " of the mpv_render_context."]
#[doc = " Type: Display*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_X11_DISPLAY: mpv_render_param_type = 8;
#[doc = " Wayland display, sometimes used for hwdec. Valid for"]
#[doc = " mpv_render_context_create(). The wl_display must stay valid for the"]
#[doc = " lifetime of the mpv_render_context."]
#[doc = " Type: struct wl_display*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_WL_DISPLAY: mpv_render_param_type = 9;
#[doc = " Better control about rendering and enabling some advanced features. Valid"]
#[doc = " for mpv_render_context_create()."]
#[doc = ""]
#[doc = " This conflates multiple requirements the API user promises to abide if"]
#[doc = " this option is enabled:"]
#[doc = ""]
#[doc = "  - The API user's render thread, which is calling the mpv_render_*()"]
#[doc = "    functions, never waits for the core. Otherwise deadlocks can happen."]
#[doc = "    See \"Threading\" section."]
#[doc = "  - The callback set with mpv_render_context_set_update_callback() can now"]
#[doc = "    be called even if there is no new frame. The API user should call the"]
#[doc = "    mpv_render_context_update() function, and interpret the return value"]
#[doc = "    for whether a new frame should be rendered."]
#[doc = "  - Correct functionality is impossible if the update callback is not set,"]
#[doc = "    or not set soon enough after mpv_render_context_create() (the core can"]
#[doc = "    block while waiting for you to call mpv_render_context_update(), and"]
#[doc = "    if the update callback is not correctly set, it will deadlock, or"]
#[doc = "    block for too long)."]
#[doc = ""]
#[doc = " In general, setting this option will enable the following features (and"]
#[doc = " possibly more):"]
#[doc = ""]
#[doc = "  - \"Direct rendering\", which means the player decodes directly to a"]
#[doc = "    texture, which saves a copy per video frame (\"vd-lavc-dr\" option"]
#[doc = "    needs to be enabled, and the rendering backend as well as the"]
#[doc = "    underlying GPU API/driver needs to have support for it)."]
#[doc = "  - Rendering screenshots with the GPU API if supported by the backend"]
#[doc = "    (instead of using a suboptimal software fallback via libswscale)."]
#[doc = ""]
#[doc = " Warning: do not just add this without reading the \"Threading\" section"]
#[doc = "          above, and then wondering that deadlocks happen. The"]
#[doc = "          requirements are tricky. But also note that even if advanced"]
#[doc = "          control is disabled, not adhering to the rules will lead to"]
#[doc = "          playback problems. Enabling advanced controls simply makes"]
#[doc = "          violating these rules fatal."]
#[doc = ""]
#[doc = " Type: int*: 0 for disable (default), 1 for enable"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_ADVANCED_CONTROL: mpv_render_param_type = 10;
#[doc = " Return information about the next frame to render. Valid for"]
#[doc = " mpv_render_context_get_info()."]
#[doc = ""]
#[doc = " Type: mpv_render_frame_info*"]
#[doc = ""]
#[doc = " It strictly returns information about the _next_ frame. The implication"]
#[doc = " is that e.g. mpv_render_context_update()'s return value will have"]
#[doc = " MPV_RENDER_UPDATE_FRAME set, and the user is supposed to call"]
#[doc = " mpv_render_context_render(). If there is no next frame, then the"]
#[doc = " return value will have is_valid set to 0."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_NEXT_FRAME_INFO: mpv_render_param_type = 11;
#[doc = " Enable or disable video timing. Valid for mpv_render_context_render()."]
#[doc = ""]
#[doc = " Type: int*: 0 for disable, 1 for enable (default)"]
#[doc = ""]
#[doc = " When video is timed to audio, the player attempts to render video a bit"]
#[doc = " ahead, and then do a blocking wait until the target display time is"]
#[doc = " reached. This blocks mpv_render_context_render() for up to the amount"]
#[doc = " specified with the \"video-timing-offset\" global option. You can set"]
#[doc = " this parameter to 0 to disable this kind of waiting. If you do, it's"]
#[doc = " recommended to use the target time value in mpv_render_frame_info to"]
#[doc = " wait yourself, or to set the \"video-timing-offset\" to 0 instead."]
#[doc = ""]
#[doc = " Disabling this without doing anything in addition will result in A/V sync"]
#[doc = " being slightly off."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_BLOCK_FOR_TARGET_TIME: mpv_render_param_type = 12;
#[doc = " Use to skip rendering in mpv_render_context_render()."]
#[doc = ""]
#[doc = " Type: int*: 0 for rendering (default), 1 for skipping"]
#[doc = ""]
#[doc = " If this is set, you don't need to pass a target surface to the render"]
#[doc = " function (and if you do, it's completely ignored). This can still call"]
#[doc = " into the lower level APIs (i.e. if you use OpenGL, the OpenGL context"]
#[doc = " must be set)."]
#[doc = ""]
#[doc = " Be aware that the render API will consider this frame as having been"]
#[doc = " rendered. All other normal rules also apply, for example about whether"]
#[doc = " you have to call mpv_render_context_report_swap(). It also does timing"]
#[doc = " in the same way."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_SKIP_RENDERING: mpv_render_param_type = 13;
#[doc = " Deprecated. Not supported. Use MPV_RENDER_PARAM_DRM_DISPLAY_V2 instead."]
#[doc = " Type : struct mpv_opengl_drm_params*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_DRM_DISPLAY: mpv_render_param_type = 14;
#[doc = " DRM draw surface size, contains draw surface dimensions."]
#[doc = " Valid for mpv_render_context_create()."]
#[doc = " Type : struct mpv_opengl_drm_draw_surface_size*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE: mpv_render_param_type = 15;
#[doc = " DRM display, contains drm display handles."]
#[doc = " Valid for mpv_render_context_create()."]
#[doc = " Type : struct mpv_opengl_drm_params_v2*"]
pub const mpv_render_param_type_MPV_RENDER_PARAM_DRM_DISPLAY_V2: mpv_render_param_type = 16;
#[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface size, mandatory."]
#[doc = " Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render()."]
#[doc = " Type: int[2] (e.g.: int s[2] = {w, h}; param.data = &s[0];)"]
#[doc = ""]
#[doc = " The video frame is transformed as with other VOs. Typically, this means"]
#[doc = " the video gets scaled and black bars are added if the video size or"]
#[doc = " aspect ratio mismatches with the target size."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_SW_SIZE: mpv_render_param_type = 17;
#[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface pixel format,"]
#[doc = " mandatory."]
#[doc = " Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render()."]
#[doc = " Type: char* (e.g.: char *f = \"rgb0\"; param.data = f;)"]
#[doc = ""]
#[doc = " Valid values are:"]
#[doc = "  \"rgb0\", \"bgr0\", \"0bgr\", \"0rgb\""]
#[doc = "      4 bytes per pixel RGB, 1 byte (8 bit) per component, component bytes"]
#[doc = "      with increasing address from left to right (e.g. \"rgb0\" has r at"]
#[doc = "      address 0), the \"0\" component contains uninitialized garbage (often"]
#[doc = "      the value 0, but not necessarily; the bad naming is inherited from"]
#[doc = "      FFmpeg)"]
#[doc = "      Pixel alignment size: 4 bytes"]
#[doc = "  \"rgb24\""]
#[doc = "      3 bytes per pixel RGB. This is strongly discouraged because it is"]
#[doc = "      very slow."]
#[doc = "      Pixel alignment size: 1 bytes"]
#[doc = "  other"]
#[doc = "      The API may accept other pixel formats, using mpv internal format"]
#[doc = "      names, as long as it's internally marked as RGB, has exactly 1"]
#[doc = "      plane, and is supported as conversion output. It is not a good idea"]
#[doc = "      to rely on any of these. Their semantics and handling could change."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_SW_FORMAT: mpv_render_param_type = 18;
#[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line,"]
#[doc = " mandatory."]
#[doc = " Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render()."]
#[doc = " Type: size_t*"]
#[doc = ""]
#[doc = " This is the number of bytes between a pixel (x, y) and (x, y + 1) on the"]
#[doc = " target surface. It must be a multiple of the pixel size, and have space"]
#[doc = " for the surface width as specified by MPV_RENDER_PARAM_SW_SIZE."]
#[doc = ""]
#[doc = " Both stride and pointer value should be a multiple of 64 to facilitate"]
#[doc = " fast SIMD operation. Lower alignment might trigger slower code paths,"]
#[doc = " and in the worst case, will copy the entire target frame. If mpv is built"]
#[doc = " with zimg (and zimg is not disabled), the performance impact might be"]
#[doc = " less."]
#[doc = " In either cases, the pointer and stride must be aligned at least to the"]
#[doc = " pixel alignment size. Otherwise, crashes and undefined behavior is"]
#[doc = " possible on platforms which do not support unaligned accesses (either"]
#[doc = " through normal memory access or aligned SIMD memory access instructions)."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_SW_STRIDE: mpv_render_param_type = 19;
#[doc = " MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line,"]
#[doc = " mandatory."]
#[doc = " Valid for MPV_RENDER_API_TYPE_SW & mpv_render_context_render()."]
#[doc = " Type: size_t*"]
#[doc = ""]
#[doc = " This is the number of bytes between a pixel (x, y) and (x, y + 1) on the"]
#[doc = " target surface. It must be a multiple of the pixel size, and have space"]
#[doc = " for the surface width as specified by MPV_RENDER_PARAM_SW_SIZE."]
#[doc = ""]
#[doc = " Both stride and pointer value should be a multiple of 64 to facilitate"]
#[doc = " fast SIMD operation. Lower alignment might trigger slower code paths,"]
#[doc = " and in the worst case, will copy the entire target frame. If mpv is built"]
#[doc = " with zimg (and zimg is not disabled), the performance impact might be"]
#[doc = " less."]
#[doc = " In either cases, the pointer and stride must be aligned at least to the"]
#[doc = " pixel alignment size. Otherwise, crashes and undefined behavior is"]
#[doc = " possible on platforms which do not support unaligned accesses (either"]
#[doc = " through normal memory access or aligned SIMD memory access instructions)."]
pub const mpv_render_param_type_MPV_RENDER_PARAM_SW_POINTER: mpv_render_param_type = 20;
#[doc = " Parameters for mpv_render_param (which is used in a few places such as"]
#[doc = " mpv_render_context_create()."]
#[doc = ""]
#[doc = " Also see mpv_render_param for conventions and how to use it."]
pub type mpv_render_param_type = u32;
#[doc = " Used to pass arbitrary parameters to some mpv_render_* functions. The"]
#[doc = " meaning of the data parameter is determined by the type, and each"]
#[doc = " MPV_RENDER_PARAM_* documents what type the value must point to."]
#[doc = ""]
#[doc = " Each value documents the required data type as the pointer you cast to"]
#[doc = " void* and set on mpv_render_param.data. For example, if MPV_RENDER_PARAM_FOO"]
#[doc = " documents the type as Something* , then the code should look like this:"]
#[doc = ""]
#[doc = "   Something foo = {...};"]
#[doc = "   mpv_render_param param;"]
#[doc = "   param.type = MPV_RENDER_PARAM_FOO;"]
#[doc = "   param.data = & foo;"]
#[doc = ""]
#[doc = " Normally, the data field points to exactly 1 object. If the type is char*,"]
#[doc = " it points to a 0-terminated string."]
#[doc = ""]
#[doc = " In all cases (unless documented otherwise) the pointers need to remain"]
#[doc = " valid during the call only. Unless otherwise documented, the API functions"]
#[doc = " will not write to the params array or any data pointed to it."]
#[doc = ""]
#[doc = " As a convention, parameter arrays are always terminated by type==0. There"]
#[doc = " is no specific order of the parameters required. The order of the 2 fields in"]
#[doc = " this struct is guaranteed (even after ABI changes)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_render_param {
    pub type_: mpv_render_param_type,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mpv_render_param() {
    assert_eq!(
        ::std::mem::size_of::<mpv_render_param>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_render_param))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_render_param>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_render_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_render_param>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_render_param),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_render_param>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_render_param),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Set if there is actually a next frame. If unset, there is no next frame"]
#[doc = " yet, and other flags and fields that require a frame to be queued will"]
#[doc = " be unset."]
#[doc = ""]
#[doc = " This is set for _any_ kind of frame, even for redraw requests."]
#[doc = ""]
#[doc = " Note that when this is unset, it simply means no new frame was"]
#[doc = " decoded/queued yet, not necessarily that the end of the video was"]
#[doc = " reached. A new frame can be queued after some time."]
#[doc = ""]
#[doc = " If the return value of mpv_render_context_render() had the"]
#[doc = " MPV_RENDER_UPDATE_FRAME flag set, this flag will usually be set as well,"]
#[doc = " unless the frame is rendered, or discarded by other asynchronous events."]
pub const mpv_render_frame_info_flag_MPV_RENDER_FRAME_INFO_PRESENT: mpv_render_frame_info_flag = 1;
#[doc = " If set, the frame is not an actual new video frame, but a redraw request."]
#[doc = " For example if the video is paused, and an option that affects video"]
#[doc = " rendering was changed (or any other reason), an update request can be"]
#[doc = " issued and this flag will be set."]
#[doc = ""]
#[doc = " Typically, redraw frames will not be subject to video timing."]
#[doc = ""]
#[doc = " Implies MPV_RENDER_FRAME_INFO_PRESENT."]
pub const mpv_render_frame_info_flag_MPV_RENDER_FRAME_INFO_REDRAW: mpv_render_frame_info_flag = 2;
#[doc = " If set, this is supposed to reproduce the previous frame perfectly. This"]
#[doc = " is usually used for certain \"video-sync\" options (\"display-...\" modes)."]
#[doc = " Typically the renderer will blit the video from a FBO. Unset otherwise."]
#[doc = ""]
#[doc = " Implies MPV_RENDER_FRAME_INFO_PRESENT."]
pub const mpv_render_frame_info_flag_MPV_RENDER_FRAME_INFO_REPEAT: mpv_render_frame_info_flag = 4;
#[doc = " If set, the player timing code expects that the user thread blocks on"]
#[doc = " vsync (by either delaying the render call, or by making a call to"]
#[doc = " mpv_render_context_report_swap() at vsync time)."]
#[doc = ""]
#[doc = " Implies MPV_RENDER_FRAME_INFO_PRESENT."]
pub const mpv_render_frame_info_flag_MPV_RENDER_FRAME_INFO_BLOCK_VSYNC: mpv_render_frame_info_flag =
    8;
#[doc = " Flags used in mpv_render_frame_info.flags. Each value represents a bit in it."]
pub type mpv_render_frame_info_flag = u32;
#[doc = " Information about the next video frame that will be rendered. Can be"]
#[doc = " retrieved with MPV_RENDER_PARAM_NEXT_FRAME_INFO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_render_frame_info {
    #[doc = " A bitset of mpv_render_frame_info_flag values (i.e. multiple flags are"]
    #[doc = " combined with bitwise or)."]
    pub flags: u64,
    #[doc = " Absolute time at which the frame is supposed to be displayed. This is in"]
    #[doc = " the same unit and base as the time returned by mpv_get_time_us(). For"]
    #[doc = " frames that are redrawn, or if vsync locked video timing is used (see"]
    #[doc = " \"video-sync\" option), then this can be 0. The \"video-timing-offset\""]
    #[doc = " option determines how much \"headroom\" the render thread gets (but a high"]
    #[doc = " enough frame rate can reduce it anyway). mpv_render_context_render() will"]
    #[doc = " normally block until the time is elapsed, unless you pass it"]
    #[doc = " MPV_RENDER_PARAM_BLOCK_FOR_TARGET_TIME = 0."]
    pub target_time: i64,
}
#[test]
fn bindgen_test_layout_mpv_render_frame_info() {
    assert_eq!(
        ::std::mem::size_of::<mpv_render_frame_info>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_render_frame_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_render_frame_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_render_frame_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_render_frame_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_render_frame_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_render_frame_info>())).target_time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_render_frame_info),
            "::",
            stringify!(target_time)
        )
    );
}
extern "C" {
    #[doc = " Initialize the renderer state. Depending on the backend used, this will"]
    #[doc = " access the underlying GPU API and initialize its own objects."]
    #[doc = ""]
    #[doc = " You must free the context with mpv_render_context_free(). Not doing so before"]
    #[doc = " the mpv core is destroyed may result in memory leaks or crashes."]
    #[doc = ""]
    #[doc = " Currently, only at most 1 context can exists per mpv core (it represents the"]
    #[doc = " main video output)."]
    #[doc = ""]
    #[doc = " You should pass the following parameters:"]
    #[doc = "  - MPV_RENDER_PARAM_API_TYPE to select the underlying backend/GPU API."]
    #[doc = "  - Backend-specific init parameter, like MPV_RENDER_PARAM_OPENGL_INIT_PARAMS."]
    #[doc = "  - Setting MPV_RENDER_PARAM_ADVANCED_CONTROL and following its rules is"]
    #[doc = "    strongly recommended."]
    #[doc = "  - If you want to use hwdec, possibly hwdec interop resources."]
    #[doc = ""]
    #[doc = " @param res set to the context (on success) or NULL (on failure). The value"]
    #[doc = "            is never read and always overwritten."]
    #[doc = " @param mpv handle used to get the core (the mpv_render_context won't depend"]
    #[doc = "            on this specific handle, only the core referenced by it)"]
    #[doc = " @param params an array of parameters, terminated by type==0. It's left"]
    #[doc = "               unspecified what happens with unknown parameters. At least"]
    #[doc = "               MPV_RENDER_PARAM_API_TYPE is required, and most backends will"]
    #[doc = "               require another backend-specific parameter."]
    #[doc = " @return error code, including but not limited to:"]
    #[doc = "      MPV_ERROR_UNSUPPORTED: the OpenGL version is not supported"]
    #[doc = "                             (or required extensions are missing)"]
    #[doc = "      MPV_ERROR_NOT_IMPLEMENTED: an unknown API type was provided, or"]
    #[doc = "                                 support for the requested API was not"]
    #[doc = "                                 built in the used libmpv binary."]
    #[doc = "      MPV_ERROR_INVALID_PARAMETER: at least one of the provided parameters was"]
    #[doc = "                                   not valid."]
    pub fn mpv_render_context_create(
        res: *mut *mut mpv_render_context,
        mpv: *mut mpv_handle,
        params: *mut mpv_render_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempt to change a single parameter. Not all backends and parameter types"]
    #[doc = " support all kinds of changes."]
    #[doc = ""]
    #[doc = " @param ctx a valid render context"]
    #[doc = " @param param the parameter type and data that should be set"]
    #[doc = " @return error code. If a parameter could actually be changed, this returns"]
    #[doc = "         success, otherwise an error code depending on the parameter type"]
    #[doc = "         and situation."]
    pub fn mpv_render_context_set_parameter(
        ctx: *mut mpv_render_context,
        param: mpv_render_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information from the render context. This is NOT a counterpart to"]
    #[doc = " mpv_render_context_set_parameter(), because you generally can't read"]
    #[doc = " parameters set with it, and this function is not meant for this purpose."]
    #[doc = " Instead, this is for communicating information from the renderer back to the"]
    #[doc = " user. See mpv_render_param_type; entries which support this function"]
    #[doc = " explicitly mention it, and for other entries you can assume it will fail."]
    #[doc = ""]
    #[doc = " You pass param with param.type set and param.data pointing to a variable"]
    #[doc = " of the required data type. The function will then overwrite that variable"]
    #[doc = " with the returned value (at least on success)."]
    #[doc = ""]
    #[doc = " @param ctx a valid render context"]
    #[doc = " @param param the parameter type and data that should be retrieved"]
    #[doc = " @return error code. If a parameter could actually be retrieved, this returns"]
    #[doc = "         success, otherwise an error code depending on the parameter type"]
    #[doc = "         and situation. MPV_ERROR_NOT_IMPLEMENTED is used for unknown"]
    #[doc = "         param.type, or if retrieving it is not supported."]
    pub fn mpv_render_context_get_info(
        ctx: *mut mpv_render_context,
        param: mpv_render_param,
    ) -> ::std::os::raw::c_int;
}
pub type mpv_render_update_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Set the callback that notifies you when a new video frame is available, or"]
    #[doc = " if the video display configuration somehow changed and requires a redraw."]
    #[doc = " Similar to mpv_set_wakeup_callback(), you must not call any mpv API from"]
    #[doc = " the callback, and all the other listed restrictions apply (such as not"]
    #[doc = " exiting the callback by throwing exceptions)."]
    #[doc = ""]
    #[doc = " This can be called from any thread, except from an update callback. In case"]
    #[doc = " of the OpenGL backend, no OpenGL state or API is accessed."]
    #[doc = ""]
    #[doc = " Calling this will raise an update callback immediately."]
    #[doc = ""]
    #[doc = " @param callback callback(callback_ctx) is called if the frame should be"]
    #[doc = "                 redrawn"]
    #[doc = " @param callback_ctx opaque argument to the callback"]
    pub fn mpv_render_context_set_update_callback(
        ctx: *mut mpv_render_context,
        callback: mpv_render_update_fn,
        callback_ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " The API user is supposed to call this when the update callback was invoked"]
    #[doc = " (like all mpv_render_* functions, this has to happen on the render thread,"]
    #[doc = " and _not_ from the update callback itself)."]
    #[doc = ""]
    #[doc = " This is optional if MPV_RENDER_PARAM_ADVANCED_CONTROL was not set (default)."]
    #[doc = " Otherwise, it's a hard requirement that this is called after each update"]
    #[doc = " callback. If multiple update callback happened, and the function could not"]
    #[doc = " be called sooner, it's OK to call it once after the last callback."]
    #[doc = ""]
    #[doc = " If an update callback happens during or after this function, the function"]
    #[doc = " must be called again at the soonest possible time."]
    #[doc = ""]
    #[doc = " If MPV_RENDER_PARAM_ADVANCED_CONTROL was set, this will do additional work"]
    #[doc = " such as allocating textures for the video decoder."]
    #[doc = ""]
    #[doc = " @return a bitset of mpv_render_update_flag values (i.e. multiple flags are"]
    #[doc = "         combined with bitwise or). Typically, this will tell the API user"]
    #[doc = "         what should happen next. E.g. if the MPV_RENDER_UPDATE_FRAME flag is"]
    #[doc = "         set, mpv_render_context_render() should be called. If flags unknown"]
    #[doc = "         to the API user are set, or if the return value is 0, nothing needs"]
    #[doc = "         to be done."]
    pub fn mpv_render_context_update(ctx: *mut mpv_render_context) -> u64;
}
#[doc = " A new video frame must be rendered. mpv_render_context_render() must be"]
#[doc = " called."]
pub const mpv_render_update_flag_MPV_RENDER_UPDATE_FRAME: mpv_render_update_flag = 1;
#[doc = " Flags returned by mpv_render_context_update(). Each value represents a bit"]
#[doc = " in the function's return value."]
pub type mpv_render_update_flag = u32;
#[doc = " Flags returned by mpv_render_context_update(). Each value represents a bit"]
#[doc = " in the function's return value."]
pub use self::mpv_render_update_flag as mpv_render_context_flag;
extern "C" {
    #[doc = " Render video."]
    #[doc = ""]
    #[doc = " Typically renders the video to a target surface provided via mpv_render_param"]
    #[doc = " (the details depend on the backend in use). Options like \"panscan\" are"]
    #[doc = " applied to determine which part of the video should be visible and how the"]
    #[doc = " video should be scaled. You can change these options at runtime by using the"]
    #[doc = " mpv property API."]
    #[doc = ""]
    #[doc = " The renderer will reconfigure itself every time the target surface"]
    #[doc = " configuration (such as size) is changed."]
    #[doc = ""]
    #[doc = " This function implicitly pulls a video frame from the internal queue and"]
    #[doc = " renders it. If no new frame is available, the previous frame is redrawn."]
    #[doc = " The update callback set with mpv_render_context_set_update_callback()"]
    #[doc = " notifies you when a new frame was added. The details potentially depend on"]
    #[doc = " the backends and the provided parameters."]
    #[doc = ""]
    #[doc = " Generally, libmpv will invoke your update callback some time before the video"]
    #[doc = " frame should be shown, and then lets this function block until the supposed"]
    #[doc = " display time. This will limit your rendering to video FPS. You can prevent"]
    #[doc = " this by setting the \"video-timing-offset\" global option to 0. (This applies"]
    #[doc = " only to \"audio\" video sync mode.)"]
    #[doc = ""]
    #[doc = " You should pass the following parameters:"]
    #[doc = "  - Backend-specific target object, such as MPV_RENDER_PARAM_OPENGL_FBO."]
    #[doc = "  - Possibly transformations, such as MPV_RENDER_PARAM_FLIP_Y."]
    #[doc = ""]
    #[doc = " @param ctx a valid render context"]
    #[doc = " @param params an array of parameters, terminated by type==0. Which parameters"]
    #[doc = "               are required depends on the backend. It's left unspecified what"]
    #[doc = "               happens with unknown parameters."]
    #[doc = " @return error code"]
    pub fn mpv_render_context_render(
        ctx: *mut mpv_render_context,
        params: *mut mpv_render_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tell the renderer that a frame was flipped at the given time. This is"]
    #[doc = " optional, but can help the player to achieve better timing."]
    #[doc = ""]
    #[doc = " Note that calling this at least once informs libmpv that you will use this"]
    #[doc = " function. If you use it inconsistently, expect bad video playback."]
    #[doc = ""]
    #[doc = " If this is called while no video is initialized, it is ignored."]
    #[doc = ""]
    #[doc = " @param ctx a valid render context"]
    pub fn mpv_render_context_report_swap(ctx: *mut mpv_render_context);
}
extern "C" {
    #[doc = " Destroy the mpv renderer state."]
    #[doc = ""]
    #[doc = " If video is still active (e.g. a file playing), video will be disabled"]
    #[doc = " forcefully."]
    #[doc = ""]
    #[doc = " @param ctx a valid render context. After this function returns, this is not"]
    #[doc = "            a valid pointer anymore. NULL is also allowed and does nothing."]
    pub fn mpv_render_context_free(ctx: *mut mpv_render_context);
}
#[doc = " For initializing the mpv OpenGL state via MPV_RENDER_PARAM_OPENGL_INIT_PARAMS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_init_params {
    #[doc = " This retrieves OpenGL function pointers, and will use them in subsequent"]
    #[doc = " operation."]
    #[doc = " Usually, you can simply call the GL context APIs from this callback (e.g."]
    #[doc = " glXGetProcAddressARB or wglGetProcAddress), but some APIs do not always"]
    #[doc = " return pointers for all standard functions (even if present); in this"]
    #[doc = " case you have to compensate by looking up these functions yourself when"]
    #[doc = " libmpv wants to resolve them through this callback."]
    #[doc = " libmpv will not normally attempt to resolve GL functions on its own, nor"]
    #[doc = " does it link to GL libraries directly."]
    pub get_proc_address: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            name: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Value passed as ctx parameter to get_proc_address()."]
    pub get_proc_address_ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mpv_opengl_init_params() {
    assert_eq!(
        ::std::mem::size_of::<mpv_opengl_init_params>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_opengl_init_params))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_opengl_init_params>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_opengl_init_params))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_init_params>())).get_proc_address as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_init_params),
            "::",
            stringify!(get_proc_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_init_params>())).get_proc_address_ctx as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_init_params),
            "::",
            stringify!(get_proc_address_ctx)
        )
    );
}
#[doc = " For MPV_RENDER_PARAM_OPENGL_FBO."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_fbo {
    #[doc = " Framebuffer object name. This must be either a valid FBO generated by"]
    #[doc = " glGenFramebuffers() that is complete and color-renderable, or 0. If the"]
    #[doc = " value is 0, this refers to the OpenGL default framebuffer."]
    pub fbo: ::std::os::raw::c_int,
    #[doc = " Valid dimensions. This must refer to the size of the framebuffer. This"]
    #[doc = " must always be set."]
    pub w: ::std::os::raw::c_int,
    #[doc = " Valid dimensions. This must refer to the size of the framebuffer. This"]
    #[doc = " must always be set."]
    pub h: ::std::os::raw::c_int,
    #[doc = " Underlying texture internal format (e.g. GL_RGBA8), or 0 if unknown. If"]
    #[doc = " this is the default framebuffer, this can be an equivalent."]
    pub internal_format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mpv_opengl_fbo() {
    assert_eq!(
        ::std::mem::size_of::<mpv_opengl_fbo>(),
        16usize,
        concat!("Size of: ", stringify!(mpv_opengl_fbo))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_opengl_fbo>(),
        4usize,
        concat!("Alignment of ", stringify!(mpv_opengl_fbo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_fbo>())).fbo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_fbo),
            "::",
            stringify!(fbo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_fbo>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_fbo),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_fbo>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_fbo),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_fbo>())).internal_format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_fbo),
            "::",
            stringify!(internal_format)
        )
    );
}
#[doc = " Deprecated. For MPV_RENDER_PARAM_DRM_DISPLAY."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_drm_params {
    pub fd: ::std::os::raw::c_int,
    pub crtc_id: ::std::os::raw::c_int,
    pub connector_id: ::std::os::raw::c_int,
    pub atomic_request_ptr: *mut *mut _drmModeAtomicReq,
    pub render_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mpv_opengl_drm_params() {
    assert_eq!(
        ::std::mem::size_of::<mpv_opengl_drm_params>(),
        32usize,
        concat!("Size of: ", stringify!(mpv_opengl_drm_params))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_opengl_drm_params>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_opengl_drm_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_drm_params>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_drm_params>())).crtc_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_params>())).connector_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params),
            "::",
            stringify!(connector_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_params>())).atomic_request_ptr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params),
            "::",
            stringify!(atomic_request_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_drm_params>())).render_fd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params),
            "::",
            stringify!(render_fd)
        )
    );
}
#[doc = " For MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_drm_draw_surface_size {
    #[doc = " size of the draw plane surface in pixels."]
    pub width: ::std::os::raw::c_int,
    #[doc = " size of the draw plane surface in pixels."]
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mpv_opengl_drm_draw_surface_size() {
    assert_eq!(
        ::std::mem::size_of::<mpv_opengl_drm_draw_surface_size>(),
        8usize,
        concat!("Size of: ", stringify!(mpv_opengl_drm_draw_surface_size))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_opengl_drm_draw_surface_size>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mpv_opengl_drm_draw_surface_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_draw_surface_size>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_draw_surface_size),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_draw_surface_size>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_draw_surface_size),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " For MPV_RENDER_PARAM_DRM_DISPLAY_V2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_drm_params_v2 {
    #[doc = " DRM fd (int). Set to -1 if invalid."]
    pub fd: ::std::os::raw::c_int,
    #[doc = " Currently used crtc id"]
    pub crtc_id: ::std::os::raw::c_int,
    #[doc = " Currently used connector id"]
    pub connector_id: ::std::os::raw::c_int,
    #[doc = " Pointer to a drmModeAtomicReq pointer that is being used for the renderloop."]
    #[doc = " This pointer should hold a pointer to the atomic request pointer"]
    #[doc = " The atomic request pointer is usually changed at every renderloop."]
    pub atomic_request_ptr: *mut *mut _drmModeAtomicReq,
    #[doc = " DRM render node. Used for VAAPI interop."]
    #[doc = " Set to -1 if invalid."]
    pub render_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mpv_opengl_drm_params_v2() {
    assert_eq!(
        ::std::mem::size_of::<mpv_opengl_drm_params_v2>(),
        32usize,
        concat!("Size of: ", stringify!(mpv_opengl_drm_params_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_opengl_drm_params_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_opengl_drm_params_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_opengl_drm_params_v2>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params_v2),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_params_v2>())).crtc_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params_v2),
            "::",
            stringify!(crtc_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_params_v2>())).connector_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params_v2),
            "::",
            stringify!(connector_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_params_v2>())).atomic_request_ptr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params_v2),
            "::",
            stringify!(atomic_request_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpv_opengl_drm_params_v2>())).render_fd as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_opengl_drm_params_v2),
            "::",
            stringify!(render_fd)
        )
    );
}
#[doc = " Read callback used to implement a custom stream. The semantics of the"]
#[doc = " callback match read(2) in blocking mode. Short reads are allowed (you can"]
#[doc = " return less bytes than requested, and libmpv will retry reading the rest"]
#[doc = " with another call). If no data can be immediately read, the callback must"]
#[doc = " block until there is new data. A return of 0 will be interpreted as final"]
#[doc = " EOF, although libmpv might retry the read, or seek to a different position."]
#[doc = ""]
#[doc = " @param cookie opaque cookie identifying the stream,"]
#[doc = "               returned from mpv_stream_cb_open_fn"]
#[doc = " @param buf buffer to read data into"]
#[doc = " @param size of the buffer"]
#[doc = " @return number of bytes read into the buffer"]
#[doc = " @return 0 on EOF"]
#[doc = " @return -1 on error"]
pub type mpv_stream_cb_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_char,
        nbytes: u64,
    ) -> i64,
>;
#[doc = " Seek callback used to implement a custom stream."]
#[doc = ""]
#[doc = " Note that mpv will issue a seek to position 0 immediately after opening. This"]
#[doc = " is used to test whether the stream is seekable (since seekability might"]
#[doc = " depend on the URI contents, not just the protocol). Return"]
#[doc = " MPV_ERROR_UNSUPPORTED if seeking is not implemented for this stream. This"]
#[doc = " seek also serves to establish the fact that streams start at position 0."]
#[doc = ""]
#[doc = " This callback can be NULL, in which it behaves as if always returning"]
#[doc = " MPV_ERROR_UNSUPPORTED."]
#[doc = ""]
#[doc = " @param cookie opaque cookie identifying the stream,"]
#[doc = "               returned from mpv_stream_cb_open_fn"]
#[doc = " @param offset target absolut stream position"]
#[doc = " @return the resulting offset of the stream"]
#[doc = "         MPV_ERROR_UNSUPPORTED or MPV_ERROR_GENERIC if the seek failed"]
pub type mpv_stream_cb_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void, offset: i64) -> i64,
>;
#[doc = " Size callback used to implement a custom stream."]
#[doc = ""]
#[doc = " Return MPV_ERROR_UNSUPPORTED if no size is known."]
#[doc = ""]
#[doc = " This callback can be NULL, in which it behaves as if always returning"]
#[doc = " MPV_ERROR_UNSUPPORTED."]
#[doc = ""]
#[doc = " @param cookie opaque cookie identifying the stream,"]
#[doc = "               returned from mpv_stream_cb_open_fn"]
#[doc = " @return the total size in bytes of the stream"]
pub type mpv_stream_cb_size_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void) -> i64>;
#[doc = " Close callback used to implement a custom stream."]
#[doc = ""]
#[doc = " @param cookie opaque cookie identifying the stream,"]
#[doc = "               returned from mpv_stream_cb_open_fn"]
pub type mpv_stream_cb_close_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
#[doc = " Cancel callback used to implement a custom stream."]
#[doc = ""]
#[doc = " This callback is used to interrupt any current or future read and seek"]
#[doc = " operations. It will be called from a separate thread than the demux"]
#[doc = " thread, and should not block."]
#[doc = ""]
#[doc = " This callback can be NULL."]
#[doc = ""]
#[doc = " Available since API 1.106."]
#[doc = ""]
#[doc = " @param cookie opaque cookie identifying the stream,"]
#[doc = "               returned from mpv_stream_cb_open_fn"]
pub type mpv_stream_cb_cancel_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
#[doc = " See mpv_stream_cb_open_ro_fn callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_stream_cb_info {
    #[doc = " Opaque user-provided value, which will be passed to the other callbacks."]
    #[doc = " The close callback will be called to release the cookie. It is not"]
    #[doc = " interpreted by mpv. It doesn't even need to be a valid pointer."]
    #[doc = ""]
    #[doc = " The user sets this in the mpv_stream_cb_open_ro_fn callback."]
    pub cookie: *mut ::std::os::raw::c_void,
    #[doc = " Callbacks set by the user in the mpv_stream_cb_open_ro_fn callback. Some"]
    #[doc = " of them are optional, and can be left unset."]
    #[doc = ""]
    #[doc = " The following callbacks are mandatory: read_fn, close_fn"]
    pub read_fn: mpv_stream_cb_read_fn,
    pub seek_fn: mpv_stream_cb_seek_fn,
    pub size_fn: mpv_stream_cb_size_fn,
    pub close_fn: mpv_stream_cb_close_fn,
    pub cancel_fn: mpv_stream_cb_cancel_fn,
}
#[test]
fn bindgen_test_layout_mpv_stream_cb_info() {
    assert_eq!(
        ::std::mem::size_of::<mpv_stream_cb_info>(),
        48usize,
        concat!("Size of: ", stringify!(mpv_stream_cb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mpv_stream_cb_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mpv_stream_cb_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_stream_cb_info>())).cookie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_stream_cb_info),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_stream_cb_info>())).read_fn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_stream_cb_info),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_stream_cb_info>())).seek_fn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_stream_cb_info),
            "::",
            stringify!(seek_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_stream_cb_info>())).size_fn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_stream_cb_info),
            "::",
            stringify!(size_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_stream_cb_info>())).close_fn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_stream_cb_info),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpv_stream_cb_info>())).cancel_fn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mpv_stream_cb_info),
            "::",
            stringify!(cancel_fn)
        )
    );
}
#[doc = " Open callback used to implement a custom read-only (ro) stream. The user"]
#[doc = " must set the callback fields in the passed info struct. The cookie field"]
#[doc = " also can be set to store state associated to the stream instance."]
#[doc = ""]
#[doc = " Note that the info struct is valid only for the duration of this callback."]
#[doc = " You can't change the callbacks or the pointer to the cookie at a later point."]
#[doc = ""]
#[doc = " Each stream instance created by the open callback can have different"]
#[doc = " callbacks."]
#[doc = ""]
#[doc = " The close_fn callback will terminate the stream instance. The pointers to"]
#[doc = " your callbacks and cookie will be discarded, and the callbacks will not be"]
#[doc = " called again."]
#[doc = ""]
#[doc = " @param user_data opaque user data provided via mpv_stream_cb_add()"]
#[doc = " @param uri name of the stream to be opened (with protocol prefix)"]
#[doc = " @param info fields which the user should fill"]
#[doc = " @return 0 on success, MPV_ERROR_LOADING_FAILED if the URI cannot be opened."]
pub type mpv_stream_cb_open_ro_fn = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        uri: *mut ::std::os::raw::c_char,
        info: *mut mpv_stream_cb_info,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Add a custom stream protocol. This will register a protocol handler under"]
    #[doc = " the given protocol prefix, and invoke the given callbacks if an URI with the"]
    #[doc = " matching protocol prefix is opened."]
    #[doc = ""]
    #[doc = " The \"ro\" is for read-only - only read-only streams can be registered with"]
    #[doc = " this function."]
    #[doc = ""]
    #[doc = " The callback remains registered until the mpv core is registered."]
    #[doc = ""]
    #[doc = " If a custom stream with the same name is already registered, then the"]
    #[doc = " MPV_ERROR_INVALID_PARAMETER error is returned."]
    #[doc = ""]
    #[doc = " @param protocol protocol prefix, for example \"foo\" for \"foo://\" URIs"]
    #[doc = " @param user_data opaque pointer passed into the mpv_stream_cb_open_fn"]
    #[doc = "                  callback."]
    #[doc = " @return error code"]
    pub fn mpv_stream_cb_add_ro(
        ctx: *mut mpv_handle,
        protocol: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
        open_fn: mpv_stream_cb_open_ro_fn,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _drmModeAtomicReq {
    pub _address: u8,
}
