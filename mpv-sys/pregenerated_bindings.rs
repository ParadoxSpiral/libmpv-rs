/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201706;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 26;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __HAVE_GENERIC_SELECTION: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_INTN_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_UINTN_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const MPV_ENABLE_DEPRECATED: ::std::os::raw::c_uint = 1;
pub type wchar_t = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    /// Return the MPV_CLIENT_API_VERSION the mpv source has been compiled with.
    pub fn mpv_client_api_version() -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_handle {
    _unused: [u8; 0],
}
#[repr(i32)]
/// List of error codes than can be returned by API functions. 0 and positive
/// return values always mean success, negative values are always errors.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpv_error {
    MPV_ERROR_SUCCESS = 0,
    MPV_ERROR_EVENT_QUEUE_FULL = -1,
    MPV_ERROR_NOMEM = -2,
    MPV_ERROR_UNINITIALIZED = -3,
    MPV_ERROR_INVALID_PARAMETER = -4,
    MPV_ERROR_OPTION_NOT_FOUND = -5,
    MPV_ERROR_OPTION_FORMAT = -6,
    MPV_ERROR_OPTION_ERROR = -7,
    MPV_ERROR_PROPERTY_NOT_FOUND = -8,
    MPV_ERROR_PROPERTY_FORMAT = -9,
    MPV_ERROR_PROPERTY_UNAVAILABLE = -10,
    MPV_ERROR_PROPERTY_ERROR = -11,
    MPV_ERROR_COMMAND = -12,
    MPV_ERROR_LOADING_FAILED = -13,
    MPV_ERROR_AO_INIT_FAILED = -14,
    MPV_ERROR_VO_INIT_FAILED = -15,
    MPV_ERROR_NOTHING_TO_PLAY = -16,
    MPV_ERROR_UNKNOWN_FORMAT = -17,
    MPV_ERROR_UNSUPPORTED = -18,
    MPV_ERROR_NOT_IMPLEMENTED = -19,
    MPV_ERROR_GENERIC = -20,
}
extern "C" {
    /// Return a string describing the error. For unknown errors, the string
/// "unknown error" is returned.
///
/// @param error error number, see enum mpv_error
/// @return A static string describing the error. The string is completely
/// static, i.e. doesn't need to be deallocated, and is valid forever.
    pub fn mpv_error_string(error: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// General function to deallocate memory returned by some of the API functions.
/// Call this only if it's explicitly documented as allowed. Calling this on
/// mpv memory not owned by the caller will lead to undefined behavior.
///
/// @param data A valid pointer returned by the API, or NULL.
    pub fn mpv_free(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Return the name of this client handle. Every client has its own unique
/// name, which is mostly used for user interface purposes.
///
/// @return The client name. The string is read-only and is valid until the
/// mpv_handle is destroyed.
    pub fn mpv_client_name(ctx: *mut mpv_handle)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Create a new mpv instance and an associated client API handle to control
/// the mpv instance. This instance is in a pre-initialized state,
/// and needs to be initialized to be actually used with most other API
/// functions.
///
/// Some API functions will return MPV_ERROR_UNINITIALIZED in the uninitialized
/// state. You can call mpv_set_property() (or mpv_set_property_string() and
/// other variants, and before mpv 0.21.0 mpv_set_option() etc.) to set initial
/// options. After this, call mpv_initialize() to start the player, and then use
/// e.g. mpv_command() to start playback of a file.
///
/// The point of separating handle creation and actual initialization is that
/// you can configure things which can't be changed during runtime.
///
/// Unlike the command line player, this will have initial settings suitable
/// for embedding in applications. The following settings are different:
/// - stdin/stdout/stderr and the terminal will never be accessed. This is
/// equivalent to setting the --no-terminal option.
/// (Technically, this also suppresses C signal handling.)
/// - No config files will be loaded. This is roughly equivalent to using
/// --no-config. Since libmpv 1.15, you can actually re-enable this option,
/// which will make libmpv load config files during mpv_initialize(). If you
/// do this, you are strongly encouraged to set the "config-dir" option too.
/// (Otherwise it will load the mpv command line player's config.)
/// - Idle mode is enabled, which means the playback core will enter idle mode
/// if there are no more files to play on the internal playlist, instead of
/// exiting. This is equivalent to the --idle option.
/// - Disable parts of input handling.
/// - Most of the different settings can be viewed with the command line player
/// by running "mpv --show-profile=libmpv".
///
/// All this assumes that API users want a mpv instance that is strictly
/// isolated from the command line player's configuration, user settings, and
/// so on. You can re-enable disabled features by setting the appropriate
/// options.
///
/// The mpv command line parser is not available through this API, but you can
/// set individual options with mpv_set_property(). Files for playback must be
/// loaded with mpv_command() or others.
///
/// Note that you should avoid doing concurrent accesses on the uninitialized
/// client handle. (Whether concurrent access is definitely allowed or not has
/// yet to be decided.)
///
/// @return a new mpv client API handle. Returns NULL on error. Currently, this
/// can happen in the following situations:
/// - out of memory
/// - LC_NUMERIC is not set to "C" (see general remarks)
    pub fn mpv_create() -> *mut mpv_handle;
}
extern "C" {
    /// Initialize an uninitialized mpv instance. If the mpv instance is already
/// running, an error is retuned.
///
/// This function needs to be called to make full use of the client API if the
/// client API handle was created with mpv_create().
///
/// Only the following options require to be set _before_ mpv_initialize():
/// - options which are only read at initialization time:
/// - config
/// - config-dir
/// - input-conf
/// - load-scripts
/// - script
/// - player-operation-mode
/// - input-app-events (OSX)
/// - all encoding mode options
///
/// @return error code
    pub fn mpv_initialize(ctx: *mut mpv_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Disconnect and destroy the mpv_handle. ctx will be deallocated with this
/// API call. This leaves the player running. If you want to be sure that the
/// player is terminated, send a "quit" command, and wait until the
/// MPV_EVENT_SHUTDOWN event is received, or use mpv_terminate_destroy().
    pub fn mpv_detach_destroy(ctx: *mut mpv_handle);
}
extern "C" {
    /// Similar to mpv_detach_destroy(), but brings the player and all clients down
/// as well, and waits until all of them are destroyed. This function blocks. The
/// advantage over mpv_detach_destroy() is that while mpv_detach_destroy() merely
/// detaches the client handle from the player, this function quits the player,
/// waits until all other clients are destroyed (i.e. all mpv_handles are
/// detached), and also waits for the final termination of the player.
///
/// Since mpv_detach_destroy() is called somewhere on the way, it's not safe to
/// call other functions concurrently on the same context.
///
/// If this is called on a mpv_handle that was not created with mpv_create(),
/// this function will merely send a quit command and then call
/// mpv_detach_destroy(), without waiting for the actual shutdown.
    pub fn mpv_terminate_destroy(ctx: *mut mpv_handle);
}
extern "C" {
    /// Create a new client handle connected to the same player core as ctx. This
/// context has its own event queue, its own mpv_request_event() state, its own
/// mpv_request_log_messages() state, its own set of observed properties, and
/// its own state for asynchronous operations. Otherwise, everything is shared.
///
/// This handle should be destroyed with mpv_detach_destroy() if no longer
/// needed. The core will live as long as there is at least 1 handle referencing
/// it. Any handle can make the core quit, which will result in every handle
/// receiving MPV_EVENT_SHUTDOWN.
///
/// This function can not be called before the main handle was initialized with
/// mpv_initialize(). The new handle is always initialized, unless ctx=NULL was
/// passed.
///
/// @param ctx Used to get the reference to the mpv core; handle-specific
/// settings and parameters are not used.
/// If NULL, this function behaves like mpv_create() (ignores name).
/// @param name The client name. This will be returned by mpv_client_name(). If
/// the name is already in use, or contains non-alphanumeric
/// characters (other than '_'), the name is modified to fit.
/// If NULL, an arbitrary name is automatically chosen.
/// @return a new handle, or NULL on error
    pub fn mpv_create_client(ctx: *mut mpv_handle,
                             name: *const ::std::os::raw::c_char)
     -> *mut mpv_handle;
}
extern "C" {
    /// Load a config file. This loads and parses the file, and sets every entry in
/// the config file's default section as if mpv_set_option_string() is called.
///
/// The filename should be an absolute path. If it isn't, the actual path used
/// is unspecified. (Note: an absolute path starts with '/' on UNIX.) If the
/// file wasn't found, MPV_ERROR_INVALID_PARAMETER is returned.
///
/// If a fatal error happens when parsing a config file, MPV_ERROR_OPTION_ERROR
/// is returned. Errors when setting options as well as other types or errors
/// are ignored (even if options do not exist). You can still try to capture
/// the resulting error messages with mpv_request_log_messages(). Note that it's
/// possible that some options were successfully set even if any of these errors
/// happen.
///
/// @param filename absolute path to the config file on the local filesystem
/// @return error code
    pub fn mpv_load_config_file(ctx: *mut mpv_handle,
                                filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This does nothing since mpv 0.23.0 (API version 1.24). Below is the
/// description of the old behavior.
///
/// Stop the playback thread. This means the core will stop doing anything, and
/// only run and answer to client API requests. This is sometimes useful; for
/// example, no new frame will be queued to the video output, so doing requests
/// which have to wait on the video output can run instantly.
///
/// Suspension is reentrant and recursive for convenience. Any thread can call
/// the suspend function multiple times, and the playback thread will remain
/// suspended until the last thread resumes it. Note that during suspension, all
/// clients still have concurrent access to the core, which is serialized through
/// a single mutex.
///
/// Call mpv_resume() to resume the playback thread. You must call mpv_resume()
/// for each mpv_suspend() call. Calling mpv_resume() more often than
/// mpv_suspend() is not allowed.
///
/// Calling this on an uninitialized player (see mpv_create()) will deadlock.
///
/// @deprecated This function, as well as mpv_resume(), are deprecated, and
/// will stop doing anything soon. Their semantics were never
/// well-defined, and their usefulness is extremely limited. The
/// calls will remain stubs in order to keep ABI compatibility.
    pub fn mpv_suspend(ctx: *mut mpv_handle);
}
extern "C" {
    /// See mpv_suspend().
    pub fn mpv_resume(ctx: *mut mpv_handle);
}
extern "C" {
    /// Return the internal time in microseconds. This has an arbitrary start offset,
/// but will never wrap or go backwards.
///
/// Note that this is always the real time, and doesn't necessarily have to do
/// with playback time. For example, playback could go faster or slower due to
/// playback speed, or due to playback being paused. Use the "time-pos" property
/// instead to get the playback status.
///
/// Unlike other libmpv APIs, this can be called at absolutely any time (even
/// within wakeup callbacks), as long as the context is valid.
    pub fn mpv_get_time_us(ctx: *mut mpv_handle) -> i64;
}
#[repr(u32)]
/// Data format for options and properties. The API functions to get/set
/// properties and options support multiple formats, and this enum describes
/// them.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpv_format {
    MPV_FORMAT_NONE = 0,
    MPV_FORMAT_STRING = 1,
    MPV_FORMAT_OSD_STRING = 2,
    MPV_FORMAT_FLAG = 3,
    MPV_FORMAT_INT64 = 4,
    MPV_FORMAT_DOUBLE = 5,
    MPV_FORMAT_NODE = 6,
    MPV_FORMAT_NODE_ARRAY = 7,
    MPV_FORMAT_NODE_MAP = 8,
    MPV_FORMAT_BYTE_ARRAY = 9,
}
/// Generic data storage.
///
/// If mpv writes this struct (e.g. via mpv_get_property()), you must not change
/// the data. In some cases (mpv_get_property()), you have to free it with
/// mpv_free_node_contents(). If you fill this struct yourself, you're also
/// responsible for freeing it, and you must not call mpv_free_node_contents().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_node {
    pub u: mpv_node__bindgen_ty_1,
    /// Type of the data stored in this struct. This value rules what members in
    /// the given union can be accessed. The following formats are currently
    /// defined to be allowed in mpv_node:
    ///
    /// MPV_FORMAT_STRING       (u.string)
    /// MPV_FORMAT_FLAG         (u.flag)
    /// MPV_FORMAT_INT64        (u.int64)
    /// MPV_FORMAT_DOUBLE       (u.double_)
    /// MPV_FORMAT_NODE_ARRAY   (u.list)
    /// MPV_FORMAT_NODE_MAP     (u.list)
    /// MPV_FORMAT_BYTE_ARRAY   (u.ba)
    /// MPV_FORMAT_NONE         (no member)
    ///
    /// If you encounter a value you don't know, you must not make any
    /// assumptions about the contents of union u.
    pub format: mpv_format,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_node__bindgen_ty_1 {
    pub string: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    /// valid if format==MPV_FORMAT_STRING
    pub flag: __BindgenUnionField<::std::os::raw::c_int>,
    /// valid if format==MPV_FORMAT_FLAG
    pub int64: __BindgenUnionField<i64>,
    /// valid if format==MPV_FORMAT_INT64
    pub double_: __BindgenUnionField<f64>,
    /// valid if format==MPV_FORMAT_DOUBLE */
    /// /**
    /// valid if format==MPV_FORMAT_NODE_ARRAY
    /// or if format==MPV_FORMAT_NODE_MAP
    pub list: __BindgenUnionField<*mut mpv_node_list>,
    /// valid if format==MPV_FORMAT_BYTE_ARRAY
    pub ba: __BindgenUnionField<*mut mpv_byte_array>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_mpv_node__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mpv_node__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( mpv_node__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<mpv_node__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mpv_node__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node__bindgen_ty_1 ) ) . string as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node__bindgen_ty_1
                ) , "::" , stringify ! ( string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node__bindgen_ty_1 ) ) . flag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node__bindgen_ty_1
                ) , "::" , stringify ! ( flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node__bindgen_ty_1 ) ) . int64 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node__bindgen_ty_1
                ) , "::" , stringify ! ( int64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node__bindgen_ty_1 ) ) . double_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node__bindgen_ty_1
                ) , "::" , stringify ! ( double_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node__bindgen_ty_1 ) ) . list as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node__bindgen_ty_1
                ) , "::" , stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node__bindgen_ty_1 ) ) . ba as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node__bindgen_ty_1
                ) , "::" , stringify ! ( ba ) ));
}
impl Clone for mpv_node__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_mpv_node() {
    assert_eq!(::std::mem::size_of::<mpv_node>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mpv_node ) ));
    assert_eq! (::std::mem::align_of::<mpv_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mpv_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node ) ) . u as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node ) ) . format as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node ) , "::" ,
                stringify ! ( format ) ));
}
impl Clone for mpv_node {
    fn clone(&self) -> Self { *self }
}
/// (see mpv_node)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_node_list {
    /// Number of entries. Negative values are not allowed.
    pub num: ::std::os::raw::c_int,
    /// MPV_FORMAT_NODE_ARRAY:
    /// values[N] refers to value of the Nth item
    ///
    /// MPV_FORMAT_NODE_MAP:
    /// values[N] refers to value of the Nth key/value pair
    ///
    /// If num > 0, values[0] to values[num-1] (inclusive) are valid.
    /// Otherwise, this can be NULL.
    pub values: *mut mpv_node,
    /// MPV_FORMAT_NODE_ARRAY:
    /// unused (typically NULL), access is not allowed
    ///
    /// MPV_FORMAT_NODE_MAP:
    /// keys[N] refers to key of the Nth key/value pair. If num > 0, keys[0] to
    /// keys[num-1] (inclusive) are valid. Otherwise, this can be NULL.
    /// The keys are in random order. The only guarantee is that keys[N] belongs
    /// to the value values[N]. NULL keys are not allowed.
    pub keys: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mpv_node_list() {
    assert_eq!(::std::mem::size_of::<mpv_node_list>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mpv_node_list ) ));
    assert_eq! (::std::mem::align_of::<mpv_node_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mpv_node_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node_list ) ) . num as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node_list ) , "::"
                , stringify ! ( num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node_list ) ) . values as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node_list ) , "::"
                , stringify ! ( values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_node_list ) ) . keys as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_node_list ) , "::"
                , stringify ! ( keys ) ));
}
impl Clone for mpv_node_list {
    fn clone(&self) -> Self { *self }
}
/// (see mpv_node)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_byte_array {
    /// Pointer to the data. In what format the data is stored is up to whatever
    /// uses MPV_FORMAT_BYTE_ARRAY.
    pub data: *mut ::std::os::raw::c_void,
    /// Size of the data pointed to by ptr.
    pub size: usize,
}
#[test]
fn bindgen_test_layout_mpv_byte_array() {
    assert_eq!(::std::mem::size_of::<mpv_byte_array>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mpv_byte_array ) ));
    assert_eq! (::std::mem::align_of::<mpv_byte_array>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mpv_byte_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_byte_array ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_byte_array ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_byte_array ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_byte_array ) , "::"
                , stringify ! ( size ) ));
}
impl Clone for mpv_byte_array {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Frees any data referenced by the node. It doesn't free the node itself.
/// Call this only if the mpv client API set the node. If you constructed the
/// node yourself (manually), you have to free it yourself.
///
/// If node->format is MPV_FORMAT_NONE, this call does nothing. Likewise, if
/// the client API sets a node with this format, this function doesn't need to
/// be called. (This is just a clarification that there's no danger of anything
/// strange happening in these cases.)
    pub fn mpv_free_node_contents(node: *mut mpv_node);
}
extern "C" {
    /// Set an option. Note that you can't normally set options during runtime. It
/// works in uninitialized state (see mpv_create()), and in some cases in at
/// runtime.
///
/// Using a format other than MPV_FORMAT_NODE is equivalent to constructing a
/// mpv_node with the given format and data, and passing the mpv_node to this
/// function.
///
/// Note: this is semi-deprecated. For most purposes, this is not needed anymore.
/// Starting with mpv version 0.21.0 (version 1.23) most options can be set
/// with mpv_set_property() (and related functions), and even before
/// mpv_initialize(). In some obscure corner cases, using this function
/// to set options might still be required (see below, and also section
/// "Inconsistencies between options and properties" on the manpage). Once
/// these are resolved, the option setting functions might be fully
/// deprecated.
///
/// The following options still need to be set either _before_
/// mpv_initialize() with mpv_set_property() (or related functions), or
/// with mpv_set_option() (or related functions) at any time:
/// - options shadowed by deprecated properties:
/// - demuxer (property deprecated in 0.21.0)
/// - idle (property deprecated in 0.21.0)
/// - fps (property deprecated in 0.21.0)
/// - cache (property deprecated in 0.21.0)
/// - length (property deprecated in 0.10.0)
/// - audio-samplerate (property deprecated in 0.10.0)
/// - audio-channels (property deprecated in 0.10.0)
/// - audio-format (property deprecated in 0.10.0)
/// - deprecated options shadowed by properties:
/// - chapter (option deprecated in 0.21.0)
/// - playlist-pos (option deprecated in 0.21.0)
/// The deprecated properties were removed in mpv 0.23.0.
///
/// @param name Option name. This is the same as on the mpv command line, but
/// without the leading "--".
/// @param format see enum mpv_format.
/// @param[in] data Option value (according to the format).
/// @return error code
    pub fn mpv_set_option(ctx: *mut mpv_handle,
                          name: *const ::std::os::raw::c_char,
                          format: mpv_format,
                          data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convenience function to set an option to a string value. This is like
/// calling mpv_set_option() with MPV_FORMAT_STRING.
///
/// @return error code
    pub fn mpv_set_option_string(ctx: *mut mpv_handle,
                                 name: *const ::std::os::raw::c_char,
                                 data: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Send a command to the player. Commands are the same as those used in
/// input.conf, except that this function takes parameters in a pre-split
/// form.
///
/// The commands and their parameters are documented in input.rst.
///
/// Does not use OSD and string expansion by default (unlike mpv_command_string()
/// and input.conf).
///
/// @param[in] args NULL-terminated list of strings. Usually, the first item
/// is the command, and the following items are arguments.
/// @return error code
    pub fn mpv_command(ctx: *mut mpv_handle,
                       args: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Same as mpv_command(), but allows passing structured data in any format.
/// In particular, calling mpv_command() is exactly like calling
/// mpv_command_node() with the format set to MPV_FORMAT_NODE_ARRAY, and
/// every arg passed in order as MPV_FORMAT_STRING.
///
/// Does not use OSD and string expansion by default.
///
/// @param[in] args mpv_node with format set to MPV_FORMAT_NODE_ARRAY; each entry
/// is an argument using an arbitrary format (the format must be
/// compatible to the used command). Usually, the first item is
/// the command name (as MPV_FORMAT_STRING).
/// @param[out] result Optional, pass NULL if unused. If not NULL, and if the
/// function succeeds, this is set to command-specific return
/// data. You must call mpv_free_node_contents() to free it
/// (again, only if the command actually succeeds).
/// Not many commands actually use this at all.
/// @return error code (the result parameter is not set on error)
    pub fn mpv_command_node(ctx: *mut mpv_handle, args: *mut mpv_node,
                            result: *mut mpv_node) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Same as mpv_command, but use input.conf parsing for splitting arguments.
/// This is slightly simpler, but also more error prone, since arguments may
/// need quoting/escaping.
///
/// This also has OSD and string expansion enabled by default.
    pub fn mpv_command_string(ctx: *mut mpv_handle,
                              args: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Same as mpv_command, but run the command asynchronously.
///
/// Commands are executed asynchronously. You will receive a
/// MPV_EVENT_COMMAND_REPLY event. (This event will also have an
/// error code set if running the command failed.)
///
/// This has nothing to do with the "async" command prefix, although they might
/// be unified in the future. For now, calling this API means that the command
/// will be synchronously executed on the core, without blocking the API user.
///
/// @param reply_userdata the value mpv_event.reply_userdata of the reply will
/// be set to (see section about asynchronous calls)
/// @param args NULL-terminated list of strings (see mpv_command())
/// @return error code (if parsing or queuing the command fails)
    pub fn mpv_command_async(ctx: *mut mpv_handle, reply_userdata: u64,
                             args: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Same as mpv_command_node(), but run it asynchronously. Basically, this
/// function is to mpv_command_node() what mpv_command_async() is to
/// mpv_command().
///
/// See mpv_command_async() for details. Retrieving the result is not
/// supported yet.
///
/// @param reply_userdata the value mpv_event.reply_userdata of the reply will
/// be set to (see section about asynchronous calls)
/// @param args as in mpv_command_node()
/// @return error code (if parsing or queuing the command fails)
    pub fn mpv_command_node_async(ctx: *mut mpv_handle, reply_userdata: u64,
                                  args: *mut mpv_node)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set a property to a given value. Properties are essentially variables which
/// can be queried or set at runtime. For example, writing to the pause property
/// will actually pause or unpause playback.
///
/// If the format doesn't match with the internal format of the property, access
/// usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data
/// is automatically converted and access succeeds. For example, MPV_FORMAT_INT64
/// is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING
/// usually invokes a string parser. The same happens when calling this function
/// with MPV_FORMAT_NODE: the underlying format may be converted to another
/// type if possible.
///
/// Using a format other than MPV_FORMAT_NODE is equivalent to constructing a
/// mpv_node with the given format and data, and passing the mpv_node to this
/// function. (Before API version 1.21, this was different.)
///
/// Note: starting with mpv 0.21.0 (client API version 1.23), this can be used to
/// set options in general. It even can be used before mpv_initialize()
/// has been called. If called before mpv_initialize(), setting properties
/// not backed by options will result in MPV_ERROR_PROPERTY_UNAVAILABLE.
/// In some cases, properties and options still conflict. In these cases,
/// mpv_set_property() accesses the options before mpv_initialize(), and
/// the properties after mpv_initialize(). These conflicts will be removed
/// in mpv 0.23.0. See mpv_set_option() for further remarks.
///
/// @param name The property name. See input.rst for a list of properties.
/// @param format see enum mpv_format.
/// @param[in] data Option value.
/// @return error code
    pub fn mpv_set_property(ctx: *mut mpv_handle,
                            name: *const ::std::os::raw::c_char,
                            format: mpv_format,
                            data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Convenience function to set a property to a string value.
///
/// This is like calling mpv_set_property() with MPV_FORMAT_STRING.
    pub fn mpv_set_property_string(ctx: *mut mpv_handle,
                                   name: *const ::std::os::raw::c_char,
                                   data: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Set a property asynchronously. You will receive the result of the operation
/// as MPV_EVENT_SET_PROPERTY_REPLY event. The mpv_event.error field will contain
/// the result status of the operation. Otherwise, this function is similar to
/// mpv_set_property().
///
/// @param reply_userdata see section about asynchronous calls
/// @param name The property name.
/// @param format see enum mpv_format.
/// @param[in] data Option value. The value will be copied by the function. It
/// will never be modified by the client API.
/// @return error code if sending the request failed
    pub fn mpv_set_property_async(ctx: *mut mpv_handle, reply_userdata: u64,
                                  name: *const ::std::os::raw::c_char,
                                  format: mpv_format,
                                  data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Read the value of the given property.
///
/// If the format doesn't match with the internal format of the property, access
/// usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data
/// is automatically converted and access succeeds. For example, MPV_FORMAT_INT64
/// is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING
/// usually invokes a string formatter.
///
/// @param name The property name.
/// @param format see enum mpv_format.
/// @param[out] data Pointer to the variable holding the option value. On
/// success, the variable will be set to a copy of the option
/// value. For formats that require dynamic memory allocation,
/// you can free the value with mpv_free() (strings) or
/// mpv_free_node_contents() (MPV_FORMAT_NODE).
/// @return error code
    pub fn mpv_get_property(ctx: *mut mpv_handle,
                            name: *const ::std::os::raw::c_char,
                            format: mpv_format,
                            data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Return the value of the property with the given name as string. This is
/// equivalent to mpv_get_property() with MPV_FORMAT_STRING.
///
/// See MPV_FORMAT_STRING for character encoding issues.
///
/// On error, NULL is returned. Use mpv_get_property() if you want fine-grained
/// error reporting.
///
/// @param name The property name.
/// @return Property value, or NULL if the property can't be retrieved. Free
/// the string with mpv_free().
    pub fn mpv_get_property_string(ctx: *mut mpv_handle,
                                   name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Return the property as "OSD" formatted string. This is the same as
/// mpv_get_property_string, but using MPV_FORMAT_OSD_STRING.
///
/// @return Property value, or NULL if the property can't be retrieved. Free
/// the string with mpv_free().
    pub fn mpv_get_property_osd_string(ctx: *mut mpv_handle,
                                       name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Get a property asynchronously. You will receive the result of the operation
/// as well as the property data with the MPV_EVENT_GET_PROPERTY_REPLY event.
/// You should check the mpv_event.error field on the reply event.
///
/// @param reply_userdata see section about asynchronous calls
/// @param name The property name.
/// @param format see enum mpv_format.
/// @return error code if sending the request failed
    pub fn mpv_get_property_async(ctx: *mut mpv_handle, reply_userdata: u64,
                                  name: *const ::std::os::raw::c_char,
                                  format: mpv_format)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get a notification whenever the given property changes. You will receive
/// updates as MPV_EVENT_PROPERTY_CHANGE. Note that this is not very precise:
/// for some properties, it may not send updates even if the property changed.
/// This depends on the property, and it's a valid feature request to ask for
/// better update handling of a specific property. (For some properties, like
/// ``clock``, which shows the wall clock, this mechanism doesn't make too
/// much sense anyway.)
///
/// Property changes are coalesced: the change events are returned only once the
/// event queue becomes empty (e.g. mpv_wait_event() would block or return
/// MPV_EVENT_NONE), and then only one event per changed property is returned.
///
/// Normally, change events are sent only if the property value changes according
/// to the requested format. mpv_event_property will contain the property value
/// as data member.
///
/// Warning: if a property is unavailable or retrieving it caused an error,
/// MPV_FORMAT_NONE will be set in mpv_event_property, even if the
/// format parameter was set to a different value. In this case, the
/// mpv_event_property.data field is invalid.
///
/// If the property is observed with the format parameter set to MPV_FORMAT_NONE,
/// you get low-level notifications whether the property _may_ have changed, and
/// the data member in mpv_event_property will be unset. With this mode, you
/// will have to determine yourself whether the property really changd. On the
/// other hand, this mechanism can be faster and uses less resources.
///
/// Observing a property that doesn't exist is allowed. (Although it may still
/// cause some sporadic change events.)
///
/// Keep in mind that you will get change notifications even if you change a
/// property yourself. Try to avoid endless feedback loops, which could happen
/// if you react to the change notifications triggered by your own change.
///
/// @param reply_userdata This will be used for the mpv_event.reply_userdata
/// field for the received MPV_EVENT_PROPERTY_CHANGE
/// events. (Also see section about asynchronous calls,
/// although this function is somewhat different from
/// actual asynchronous calls.)
/// If you have no use for this, pass 0.
/// Also see mpv_unobserve_property().
/// @param name The property name.
/// @param format see enum mpv_format. Can be MPV_FORMAT_NONE to omit values
/// from the change events.
/// @return error code (usually fails only on OOM or unsupported format)
    pub fn mpv_observe_property(mpv: *mut mpv_handle, reply_userdata: u64,
                                name: *const ::std::os::raw::c_char,
                                format: mpv_format) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Undo mpv_observe_property(). This will remove all observed properties for
/// which the given number was passed as reply_userdata to mpv_observe_property.
///
/// @param registered_reply_userdata ID that was passed to mpv_observe_property
/// @return negative value is an error code, >=0 is number of removed properties
/// on success (includes the case when 0 were removed)
    pub fn mpv_unobserve_property(mpv: *mut mpv_handle,
                                  registered_reply_userdata: u64)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpv_event_id {
    MPV_EVENT_NONE = 0,
    MPV_EVENT_SHUTDOWN = 1,
    MPV_EVENT_LOG_MESSAGE = 2,
    MPV_EVENT_GET_PROPERTY_REPLY = 3,
    MPV_EVENT_SET_PROPERTY_REPLY = 4,
    MPV_EVENT_COMMAND_REPLY = 5,
    MPV_EVENT_START_FILE = 6,
    MPV_EVENT_END_FILE = 7,
    MPV_EVENT_FILE_LOADED = 8,
    MPV_EVENT_TRACKS_CHANGED = 9,
    MPV_EVENT_TRACK_SWITCHED = 10,
    MPV_EVENT_IDLE = 11,
    MPV_EVENT_PAUSE = 12,
    MPV_EVENT_UNPAUSE = 13,
    MPV_EVENT_TICK = 14,
    MPV_EVENT_SCRIPT_INPUT_DISPATCH = 15,
    MPV_EVENT_CLIENT_MESSAGE = 16,
    MPV_EVENT_VIDEO_RECONFIG = 17,
    MPV_EVENT_AUDIO_RECONFIG = 18,
    MPV_EVENT_METADATA_UPDATE = 19,
    MPV_EVENT_SEEK = 20,
    MPV_EVENT_PLAYBACK_RESTART = 21,
    MPV_EVENT_PROPERTY_CHANGE = 22,
    MPV_EVENT_CHAPTER_CHANGE = 23,
    MPV_EVENT_QUEUE_OVERFLOW = 24,
}
extern "C" {
    /// Return a string describing the event. For unknown events, NULL is returned.
///
/// Note that all events actually returned by the API will also yield a non-NULL
/// string with this function.
///
/// @param event event ID, see see enum mpv_event_id
/// @return A static string giving a short symbolic name of the event. It
/// consists of lower-case alphanumeric characters and can include "-"
/// characters. This string is suitable for use in e.g. scripting
/// interfaces.
/// The string is completely static, i.e. doesn't need to be deallocated,
/// and is valid forever.
    pub fn mpv_event_name(event: mpv_event_id)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_event_property {
    /// Name of the property.
    pub name: *const ::std::os::raw::c_char,
    /// Format of the data field in the same struct. See enum mpv_format.
    /// This is always the same format as the requested format, except when
    /// the property could not be retrieved (unavailable, or an error happened),
    /// in which case the format is MPV_FORMAT_NONE.
    pub format: mpv_format,
    /// Received property value. Depends on the format. This is like the
    /// pointer argument passed to mpv_get_property().
    ///
    /// For example, for MPV_FORMAT_STRING you get the string with:
    ///
    /// char *value = *(char **)(event_property->data);
    ///
    /// Note that this is set to NULL if retrieving the property failed (the
    /// format will be MPV_FORMAT_NONE).
    /// See mpv_event.error for the status.
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mpv_event_property() {
    assert_eq!(::std::mem::size_of::<mpv_event_property>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( mpv_event_property ) ));
    assert_eq! (::std::mem::align_of::<mpv_event_property>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mpv_event_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_property ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_property ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_property ) ) . format as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_property ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_property ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_property ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for mpv_event_property {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Numeric log levels. The lower the number, the more important the message is.
/// MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in
/// the comment after the value is the name of the log level as used for the
/// mpv_request_log_messages() function.
/// Unused numeric values are unused, but reserved for future use.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpv_log_level {
    MPV_LOG_LEVEL_NONE = 0,
    MPV_LOG_LEVEL_FATAL = 10,
    MPV_LOG_LEVEL_ERROR = 20,
    MPV_LOG_LEVEL_WARN = 30,
    MPV_LOG_LEVEL_INFO = 40,
    MPV_LOG_LEVEL_V = 50,
    MPV_LOG_LEVEL_DEBUG = 60,
    MPV_LOG_LEVEL_TRACE = 70,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_event_log_message {
    /// The module prefix, identifies the sender of the message. As a special
    /// case, if the message buffer overflows, this will be set to the string
    /// "overflow" (which doesn't appear as prefix otherwise), and the text
    /// field will contain an informative message.
    pub prefix: *const ::std::os::raw::c_char,
    /// The log level as string. See mpv_request_log_messages() for possible
    /// values. The level "no" is never used here.
    pub level: *const ::std::os::raw::c_char,
    /// The log message. It consists of 1 line of text, and is terminated with
    /// a newline character. (Before API version 1.6, it could contain multiple
    /// or partial lines.)
    pub text: *const ::std::os::raw::c_char,
    /// The same contents as the level field, but as a numeric ID.
    /// Since API version 1.6.
    pub log_level: mpv_log_level,
}
#[test]
fn bindgen_test_layout_mpv_event_log_message() {
    assert_eq!(::std::mem::size_of::<mpv_event_log_message>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( mpv_event_log_message )
               ));
    assert_eq! (::std::mem::align_of::<mpv_event_log_message>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mpv_event_log_message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_log_message ) ) . prefix as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_log_message )
                , "::" , stringify ! ( prefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_log_message ) ) . level as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_log_message )
                , "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_log_message ) ) . text as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_log_message )
                , "::" , stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_log_message ) ) . log_level as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_log_message )
                , "::" , stringify ! ( log_level ) ));
}
impl Clone for mpv_event_log_message {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// Since API version 1.9.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpv_end_file_reason {
    MPV_END_FILE_REASON_EOF = 0,
    MPV_END_FILE_REASON_STOP = 2,
    MPV_END_FILE_REASON_QUIT = 3,
    MPV_END_FILE_REASON_ERROR = 4,
    MPV_END_FILE_REASON_REDIRECT = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_event_end_file {
    /// Corresponds to the values in enum mpv_end_file_reason (the "int" type
    /// will be replaced with mpv_end_file_reason on the next ABI bump).
    ///
    /// Unknown values should be treated as unknown.
    pub reason: ::std::os::raw::c_int,
    /// If reason==MPV_END_FILE_REASON_ERROR, this contains a mpv error code
    /// (one of MPV_ERROR_...) giving an approximate reason why playback
    /// failed. In other cases, this field is 0 (no error).
    /// Since API version 1.9.
    pub error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mpv_event_end_file() {
    assert_eq!(::std::mem::size_of::<mpv_event_end_file>() , 8usize , concat !
               ( "Size of: " , stringify ! ( mpv_event_end_file ) ));
    assert_eq! (::std::mem::align_of::<mpv_event_end_file>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( mpv_event_end_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_end_file ) ) . reason as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_end_file ) ,
                "::" , stringify ! ( reason ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_end_file ) ) . error as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event_end_file ) ,
                "::" , stringify ! ( error ) ));
}
impl Clone for mpv_event_end_file {
    fn clone(&self) -> Self { *self }
}
/// @deprecated see MPV_EVENT_SCRIPT_INPUT_DISPATCH for remarks
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_event_script_input_dispatch {
    pub arg0: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mpv_event_script_input_dispatch() {
    assert_eq!(::std::mem::size_of::<mpv_event_script_input_dispatch>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( mpv_event_script_input_dispatch )
               ));
    assert_eq! (::std::mem::align_of::<mpv_event_script_input_dispatch>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mpv_event_script_input_dispatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_script_input_dispatch ) ) .
                arg0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mpv_event_script_input_dispatch ) , "::" , stringify ! ( arg0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_script_input_dispatch ) ) .
                type_ as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mpv_event_script_input_dispatch ) , "::" , stringify ! ( type_
                ) ));
}
impl Clone for mpv_event_script_input_dispatch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_event_client_message {
    /// Arbitrary arguments chosen by the sender of the message. If num_args > 0,
    /// you can access args[0] through args[num_args - 1] (inclusive). What
    /// these arguments mean is up to the sender and receiver.
    /// None of the valid items are NULL.
    pub num_args: ::std::os::raw::c_int,
    pub args: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mpv_event_client_message() {
    assert_eq!(::std::mem::size_of::<mpv_event_client_message>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( mpv_event_client_message ) ));
    assert_eq! (::std::mem::align_of::<mpv_event_client_message>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mpv_event_client_message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_client_message ) ) . num_args
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mpv_event_client_message ) , "::" , stringify ! ( num_args )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event_client_message ) ) . args as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mpv_event_client_message ) , "::" , stringify ! ( args ) ));
}
impl Clone for mpv_event_client_message {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_event {
    /// One of mpv_event. Keep in mind that later ABI compatible releases might
    /// add new event types. These should be ignored by the API user.
    pub event_id: mpv_event_id,
    /// This is mainly used for events that are replies to (asynchronous)
    /// requests. It contains a status code, which is >= 0 on success, or < 0
    /// on error (a mpv_error value). Usually, this will be set if an
    /// asynchronous request fails.
    /// Used for:
    /// MPV_EVENT_GET_PROPERTY_REPLY
    /// MPV_EVENT_SET_PROPERTY_REPLY
    /// MPV_EVENT_COMMAND_REPLY
    pub error: ::std::os::raw::c_int,
    /// If the event is in reply to a request (made with this API and this
    /// API handle), this is set to the reply_userdata parameter of the request
    /// call. Otherwise, this field is 0.
    /// Used for:
    /// MPV_EVENT_GET_PROPERTY_REPLY
    /// MPV_EVENT_SET_PROPERTY_REPLY
    /// MPV_EVENT_COMMAND_REPLY
    /// MPV_EVENT_PROPERTY_CHANGE
    pub reply_userdata: u64,
    /// The meaning and contents of the data member depend on the event_id:
    /// MPV_EVENT_GET_PROPERTY_REPLY:     mpv_event_property*
    /// MPV_EVENT_PROPERTY_CHANGE:        mpv_event_property*
    /// MPV_EVENT_LOG_MESSAGE:            mpv_event_log_message*
    /// MPV_EVENT_CLIENT_MESSAGE:         mpv_event_client_message*
    /// MPV_EVENT_END_FILE:               mpv_event_end_file*
    /// other: NULL
    ///
    /// Note: future enhancements might add new event structs for existing or new
    /// event types.
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mpv_event() {
    assert_eq!(::std::mem::size_of::<mpv_event>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mpv_event ) ));
    assert_eq! (::std::mem::align_of::<mpv_event>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mpv_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event ) ) . event_id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event ) , "::" ,
                stringify ! ( event_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event ) ) . error as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event ) , "::" ,
                stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event ) ) . reply_userdata as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event ) , "::" ,
                stringify ! ( reply_userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_event ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_event ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for mpv_event {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Enable or disable the given event.
///
/// Some events are enabled by default. Some events can't be disabled.
///
/// (Informational note: currently, all events are enabled by default, except
/// MPV_EVENT_TICK.)
///
/// @param event See enum mpv_event_id.
/// @param enable 1 to enable receiving this event, 0 to disable it.
/// @return error code
    pub fn mpv_request_event(ctx: *mut mpv_handle, event: mpv_event_id,
                             enable: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Enable or disable receiving of log messages. These are the messages the
/// command line player prints to the terminal. This call sets the minimum
/// required log level for a message to be received with MPV_EVENT_LOG_MESSAGE.
///
/// @param min_level Minimal log level as string. Valid log levels:
/// no fatal error warn info v debug trace
/// The value "no" disables all messages. This is the default.
/// An exception is the value "terminal-default", which uses the
/// log level as set by the "--msg-level" option. This works
/// even if the terminal is disabled. (Since API version 1.19.)
/// Also see mpv_log_level.
/// @return error code
    pub fn mpv_request_log_messages(ctx: *mut mpv_handle,
                                    min_level: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait for the next event, or until the timeout expires, or if another thread
/// makes a call to mpv_wakeup(). Passing 0 as timeout will never wait, and
/// is suitable for polling.
///
/// The internal event queue has a limited size (per client handle). If you
/// don't empty the event queue quickly enough with mpv_wait_event(), it will
/// overflow and silently discard further events. If this happens, making
/// asynchronous requests will fail as well (with MPV_ERROR_EVENT_QUEUE_FULL).
///
/// Only one thread is allowed to call this on the same mpv_handle at a time.
/// The API won't complain if more than one thread calls this, but it will cause
/// race conditions in the client when accessing the shared mpv_event struct.
/// Note that most other API functions are not restricted by this, and no API
/// function internally calls mpv_wait_event(). Additionally, concurrent calls
/// to different mpv_handles are always safe.
///
/// @param timeout Timeout in seconds, after which the function returns even if
/// no event was received. A MPV_EVENT_NONE is returned on
/// timeout. A value of 0 will disable waiting. Negative values
/// will wait with an infinite timeout.
/// @return A struct containing the event ID and other data. The pointer (and
/// fields in the struct) stay valid until the next mpv_wait_event()
/// call, or until the mpv_handle is destroyed. You must not write to
/// the struct, and all memory referenced by it will be automatically
/// released by the API on the next mpv_wait_event() call, or when the
/// context is destroyed. The return value is never NULL.
    pub fn mpv_wait_event(ctx: *mut mpv_handle, timeout: f64)
     -> *mut mpv_event;
}
extern "C" {
    /// Interrupt the current mpv_wait_event() call. This will wake up the thread
/// currently waiting in mpv_wait_event(). If no thread is waiting, the next
/// mpv_wait_event() call will return immediately (this is to avoid lost
/// wakeups).
///
/// mpv_wait_event() will receive a MPV_EVENT_NONE if it's woken up due to
/// this call. But note that this dummy event might be skipped if there are
/// already other events queued. All what counts is that the waiting thread
/// is woken up at all.
    pub fn mpv_wakeup(ctx: *mut mpv_handle);
}
extern "C" {
    /// Set a custom function that should be called when there are new events. Use
/// this if blocking in mpv_wait_event() to wait for new events is not feasible.
///
/// Keep in mind that the callback will be called from foreign threads. You
/// must not make any assumptions of the environment, and you must return as
/// soon as possible. You are not allowed to call any client API functions
/// inside of the callback. In particular, you should not do any processing in
/// the callback, but wake up another thread that does all the work. It's also
/// possible that the callback is called from a thread while a mpv API function
/// is called (i.e. it can be reentrant).
///
/// In general, the client API expects you to call mpv_wait_event() to receive
/// notifications, and the wakeup callback is merely a helper utility to make
/// this easier in certain situations. Note that it's possible that there's
/// only one wakeup callback invocation for multiple events. You should call
/// mpv_wait_event() with no timeout until MPV_EVENT_NONE is reached, at which
/// point the event queue is empty.
///
/// If you actually want to do processing in a callback, spawn a thread that
/// does nothing but call mpv_wait_event() in a loop and dispatches the result
/// to a callback.
///
/// Only one wakeup callback can be set.
///
/// @param cb function that should be called if a wakeup is required
/// @param d arbitrary userdata passed to cb
    pub fn mpv_set_wakeup_callback(ctx: *mut mpv_handle,
                                   cb:
                                       ::std::option::Option<unsafe extern "C" fn(d:
                                                                                      *mut ::std::os::raw::c_void)>,
                                   d: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Return a UNIX file descriptor referring to the read end of a pipe. This
/// pipe can be used to wake up a poll() based processing loop. The purpose of
/// this function is very similar to mpv_set_wakeup_callback(), and provides
/// a primitive mechanism to handle coordinating a foreign event loop and the
/// libmpv event loop. The pipe is non-blocking. It's closed when the mpv_handle
/// is destroyed. This function always returns the same value (on success).
///
/// This is in fact implemented using the same underlying code as for
/// mpv_set_wakeup_callback() (though they don't conflict), and it is as if each
/// callback invocation writes a single 0 byte to the pipe. When the pipe
/// becomes readable, the code calling poll() (or select()) on the pipe should
/// read all contents of the pipe and then call mpv_wait_event(c, 0) until
/// no new events are returned. The pipe contents do not matter and can just
/// be discarded. There is not necessarily one byte per readable event in the
/// pipe. For example, the pipes are non-blocking, and mpv won't block if the
/// pipe is full. Pipes are normally limited to 4096 bytes, so if there are
/// more than 4096 events, the number of readable bytes can not equal the number
/// of events queued. Also, it's possible that mpv does not write to the pipe
/// once it's guaranteed that the client was already signaled. See the example
/// below how to do it correctly.
///
/// Example:
///
/// int pipefd = mpv_get_wakeup_pipe(mpv);
/// if (pipefd < 0)
/// error();
/// while (1) {
/// struct pollfd pfds[1] = {
/// { .fd = pipefd, .events = POLLIN },
/// };
/// // Wait until there are possibly new mpv events.
/// poll(pfds, 1, -1);
/// if (pfds[0].revents & POLLIN) {
/// // Empty the pipe. Doing this before calling mpv_wait_event()
/// // ensures that no wakeups are missed. It's not so important to
/// // make sure the pipe is really empty (it will just cause some
/// // additional wakeups in unlikely corner cases).
/// char unused[256];
/// read(pipefd, unused, sizeof(unused));
/// while (1) {
/// mpv_event *ev = mpv_wait_event(mpv, 0);
/// // If MPV_EVENT_NONE is received, the event queue is empty.
/// if (ev->event_id == MPV_EVENT_NONE)
/// break;
/// // Process the event.
/// ...
/// }
/// }
/// }
///
/// @return A UNIX FD of the read end of the wakeup pipe, or -1 on error.
/// On MS Windows/MinGW, this will always return -1.
    pub fn mpv_get_wakeup_pipe(ctx: *mut mpv_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Block until all asynchronous requests are done. This affects functions like
/// mpv_command_async(), which return immediately and return their result as
/// events.
///
/// This is a helper, and somewhat equivalent to calling mpv_wait_event() in a
/// loop until all known asynchronous requests have sent their reply as event,
/// except that the event queue is not emptied.
///
/// In case you called mpv_suspend() before, this will also forcibly reset the
/// suspend counter of the given handle.
    pub fn mpv_wait_async_requests(ctx: *mut mpv_handle);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpv_sub_api { MPV_SUB_API_OPENGL_CB = 1, }
extern "C" {
    /// This is used for additional APIs that are not strictly part of the core API.
/// See the individual mpv_sub_api member values.
    pub fn mpv_get_sub_api(ctx: *mut mpv_handle, sub_api: mpv_sub_api)
     -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpv_opengl_cb_context {
    _unused: [u8; 0],
}
pub type mpv_opengl_cb_update_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_ctx:
                                                   *mut ::std::os::raw::c_void)>;
pub type mpv_opengl_cb_get_proc_address_fn =
    ::std::option::Option<unsafe extern "C" fn(fn_ctx:
                                                   *mut ::std::os::raw::c_void,
                                               name:
                                                   *const ::std::os::raw::c_char)
                              -> *mut ::std::os::raw::c_void>;
extern "C" {
    /// Set the callback that notifies you when a new video frame is available, or
/// if the video display configuration somehow changed and requires a redraw.
/// Similar to mpv_set_wakeup_callback(), you must not call any mpv API from
/// the callback.
///
/// @param callback callback(callback_ctx) is called if the frame should be
/// redrawn
/// @param callback_ctx opaque argument to the callback
    pub fn mpv_opengl_cb_set_update_callback(ctx: *mut mpv_opengl_cb_context,
                                             callback:
                                                 mpv_opengl_cb_update_fn,
                                             callback_ctx:
                                                 *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Initialize the mpv OpenGL state. This retrieves OpenGL function pointers via
/// get_proc_address, and creates OpenGL objects needed by mpv internally. It
/// will also call APIs needed for rendering hardware decoded video in OpenGL,
/// according to the mpv "hwdec" option.
///
/// You must free the associated state at some point by calling the
/// mpv_opengl_cb_uninit_gl() function. Not doing so may result in memory leaks
/// or worse.
///
/// @param exts optional _additional_ extension string, can be NULL
/// @param get_proc_address callback used to retrieve function pointers to OpenGL
/// functions. This is used for both standard functions
/// and extension functions. (The extension string is
/// checked whether extensions are really available.)
/// The callback will be called from this function only
/// (it is not stored and never used later).
/// Usually, GL context APIs do this for you (e.g. with
/// glXGetProcAddressARB or wglGetProcAddress), but
/// some APIs do not always return pointers for all
/// standard functions (even if present); in this case
/// you have to compensate by looking up these functions
/// yourself.
/// @param get_proc_address_ctx arbitrary opaque user context passed to the
/// get_proc_address callback
/// @return error code (same as normal mpv_* API), including but not limited to:
/// MPV_ERROR_UNSUPPORTED: the OpenGL version is not supported
/// (or required extensions are missing)
/// MPV_ERROR_INVALID_PARAMETER: the OpenGL state was already initialized
    pub fn mpv_opengl_cb_init_gl(ctx: *mut mpv_opengl_cb_context,
                                 exts: *const ::std::os::raw::c_char,
                                 get_proc_address:
                                     mpv_opengl_cb_get_proc_address_fn,
                                 get_proc_address_ctx:
                                     *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Render video. Requires that the OpenGL state is initialized.
///
/// The video will use the full provided framebuffer. Options like "panscan" are
/// applied to determine which part of the video should be visible and how the
/// video should be scaled. You can change these options at runtime by using the
/// mpv property API.
///
/// The renderer will reconfigure itself every time the output rectangle/size
/// is changed. (If you want to do animations, it might be better to do the
/// animation on a FBO instead.)
///
/// This function implicitly pulls a video frame from the internal queue and
/// renders it. If no new frame is available, the previous frame is redrawn.
/// The update callback set with mpv_opengl_cb_set_update_callback() notifies
/// you when a new frame was added.
///
/// @param fbo The framebuffer object to render on. Because the renderer might
/// manage multiple FBOs internally for the purpose of video
/// postprocessing, it will always bind and unbind FBOs itself. If
/// you want mpv to render on the main framebuffer, pass 0.
/// @param w Width of the framebuffer. This is either the video size if the fbo
/// parameter is 0, or the allocated size of the texture backing the
/// fbo. The renderer will always use the full size of the fbo.
/// @param h Height of the framebuffer. Same as with the w parameter, except
/// that this parameter can be negative. In this case, the video
/// frame will be rendered flipped.
/// @return 0
    pub fn mpv_opengl_cb_draw(ctx: *mut mpv_opengl_cb_context,
                              fbo: ::std::os::raw::c_int,
                              w: ::std::os::raw::c_int,
                              h: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Deprecated. Use mpv_opengl_cb_draw(). This function is equivalent to:
///
/// int mpv_opengl_cb_render(mpv_opengl_cb_context *ctx, int fbo, int vp[4])
/// { return mpv_opengl_cb_draw(ctx, fbo, vp[2], vp[3]); }
///
/// vp[0] and vp[1] used to have a meaning, but are ignored in newer versions.
///
/// This function will be removed in the future without version bump (this API
/// was never marked as stable).
    pub fn mpv_opengl_cb_render(ctx: *mut mpv_opengl_cb_context,
                                fbo: ::std::os::raw::c_int,
                                vp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Tell the renderer that a frame was flipped at the given time. This is
/// optional, but can help the player to achieve better timing.
///
/// Note that calling this at least once informs libmpv that you will use this
/// function. If you use it inconsistently, expect bad video playback.
///
/// If this is called while no video or no OpenGL is initialized, it is ignored.
///
/// @param time The mpv time (using mpv_get_time_us()) at which the flip call
/// returned. If 0 is passed, mpv_get_time_us() is used instead.
/// Currently, this parameter is ignored.
/// @return error code
    pub fn mpv_opengl_cb_report_flip(ctx: *mut mpv_opengl_cb_context,
                                     time: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Destroy the mpv OpenGL state.
///
/// If video is still active (e.g. a file playing), video will be disabled
/// forcefully.
///
/// Calling this multiple times is ok.
///
/// @return error code
    pub fn mpv_opengl_cb_uninit_gl(ctx: *mut mpv_opengl_cb_context)
     -> ::std::os::raw::c_int;
}
/// Read callback used to implement a custom stream. The semantics of the
/// callback match read(2) in blocking mode. Short reads are allowed (you can
/// return less bytes than requested, and libmpv will retry reading the rest
/// with a nother call). If no data can be immediately read, the callback must
/// block until there is new data. A return of 0 will be interpreted as final
/// EOF, although libmpv might retry the read, or seek to a different position.
///
/// @param cookie opaque cookie identifying the stream,
/// returned from mpv_stream_cb_open_fn
/// @param buf buffer to read data into
/// @param size of the buffer
/// @return number of bytes read into the buffer
/// @return 0 on EOF
/// @return -1 on error
pub type mpv_stream_cb_read_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie:
                                                   *mut ::std::os::raw::c_void,
                                               buf:
                                                   *mut ::std::os::raw::c_char,
                                               nbytes: u64) -> i64>;
/// Seek callback used to implement a custom stream.
///
/// Note that mpv will issue a seek to position 0 immediately after opening. This
/// is used to test whether the stream is seekable (since seekability might
/// depend on the URI contents, not just the protocol). Return
/// MPV_ERROR_UNSUPPORTED if seeking is not implemented for this stream. This
/// seek also servies to establish the fact that streams start at position 0.
///
/// This callback can be NULL, in which it behaves as if always returning
/// MPV_ERROR_UNSUPPORTED.
///
/// @param cookie opaque cookie identifying the stream,
/// returned from mpv_stream_cb_open_fn
/// @param offset target absolut stream position
/// @return the resulting offset of the stream
/// MPV_ERROR_UNSUPPORTED or MPV_ERROR_GENERIC if the seek failed
pub type mpv_stream_cb_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie:
                                                   *mut ::std::os::raw::c_void,
                                               offset: i64) -> i64>;
/// Size callback used to implement a custom stream.
///
/// Return MPV_ERROR_UNSUPPORTED if no size is known.
///
/// This callback can be NULL, in which it behaves as if always returning
/// MPV_ERROR_UNSUPPORTED.
///
/// @param cookie opaque cookie identifying the stream,
/// returned from mpv_stream_cb_open_fn
/// @return the total size in bytes of the stream
pub type mpv_stream_cb_size_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> i64>;
/// Close callback used to implement a custom stream.
///
/// @param cookie opaque cookie identifying the stream,
/// returned from mpv_stream_cb_open_fn
pub type mpv_stream_cb_close_fn =
    ::std::option::Option<unsafe extern "C" fn(cookie:
                                                   *mut ::std::os::raw::c_void)>;
/// See mpv_stream_cb_open_ro_fn callback.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mpv_stream_cb_info {
    /// Opaque user-provided value, which will be passed to the other callbacks.
    /// The close callback will be called to release the cookie. It is not
    /// interpreted by mpv. It doesn't even need to be a valid pointer.
    ///
    /// The user sets this in the mpv_stream_cb_open_ro_fn callback.
    pub cookie: *mut ::std::os::raw::c_void,
    /// Callbacks set by the user in the mpv_stream_cb_open_ro_fn callback. Some
    /// of them are optional, and can be left unset.
    ///
    /// The following callbacks are mandatory: read_fn, close_fn
    pub read_fn: mpv_stream_cb_read_fn,
    pub seek_fn: mpv_stream_cb_seek_fn,
    pub size_fn: mpv_stream_cb_size_fn,
    pub close_fn: mpv_stream_cb_close_fn,
}
#[test]
fn bindgen_test_layout_mpv_stream_cb_info() {
    assert_eq!(::std::mem::size_of::<mpv_stream_cb_info>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( mpv_stream_cb_info ) ));
    assert_eq! (::std::mem::align_of::<mpv_stream_cb_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mpv_stream_cb_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_stream_cb_info ) ) . cookie as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_stream_cb_info ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_stream_cb_info ) ) . read_fn as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_stream_cb_info ) ,
                "::" , stringify ! ( read_fn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_stream_cb_info ) ) . seek_fn as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_stream_cb_info ) ,
                "::" , stringify ! ( seek_fn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_stream_cb_info ) ) . size_fn as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_stream_cb_info ) ,
                "::" , stringify ! ( size_fn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mpv_stream_cb_info ) ) . close_fn as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mpv_stream_cb_info ) ,
                "::" , stringify ! ( close_fn ) ));
}
impl Clone for mpv_stream_cb_info {
    fn clone(&self) -> Self { *self }
}
/// Open callback used to implement a custom read-only (ro) stream. The user
/// must set the callback fields in the passed info struct. The cookie field
/// also can be set to store state associated to the stream instance.
///
/// Note that the info struct is valid only for the duration of this callback.
/// You can't change the callbacks or the pointer to the cookie at a later point.
///
/// Each stream instance created by the open callback can have different
/// callbacks.
///
/// The close_fn callback will terminate the stream instance. The pointers to
/// your callbacks and cookie will be discarded, and the callbacks will not be
/// called again.
///
/// @param user_data opaque user data provided via mpv_stream_cb_add()
/// @param uri name of the stream to be opened (with protocol prefix)
/// @param info fields which the user should fill
/// @return 0 on success, MPV_ERROR_LOADING_FAILED if the URI cannot be opened.
pub type mpv_stream_cb_open_ro_fn =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void,
                                               uri:
                                                   *mut ::std::os::raw::c_char,
                                               info: *mut mpv_stream_cb_info)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Add a custom stream protocol. This will register a protocol handler under
/// the given protocol prefix, and invoke the given callbacks if an URI with the
/// matching protocol prefix is opened.
///
/// The "ro" is for read-only - only read-only streams can be registered with
/// this function.
///
/// The callback remains registered until the mpv core is registered.
///
/// If a custom stream with the same name is already registered, then the
/// MPV_ERROR_INVALID_PARAMETER error is returned.
///
/// @param protocol protocol prefix, for example "foo" for "foo://" URIs
/// @param user_data opaque pointer passed into the mpv_stream_cb_open_fn
/// callback.
/// @return error code
    pub fn mpv_stream_cb_add_ro(ctx: *mut mpv_handle,
                                protocol: *const ::std::os::raw::c_char,
                                user_data: *mut ::std::os::raw::c_void,
                                open_fn: mpv_stream_cb_open_ro_fn)
     -> ::std::os::raw::c_int;
}
